# coding: utf-8

"""
    Hopsworks api

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.1.0-SNAPSHOT
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class ProjectServiceApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def accept_request(self, inode_id, project_id, **kwargs):  # noqa: E501
        """accept_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_request(inode_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.accept_request_with_http_info(inode_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.accept_request_with_http_info(inode_id, project_id, **kwargs)  # noqa: E501
            return data

    def accept_request_with_http_info(self, inode_id, project_id, **kwargs):  # noqa: E501
        """accept_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.accept_request_with_http_info(inode_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inode_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method accept_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `accept_request`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `accept_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/accept/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_acls_to_topic(self, topic, project_id, **kwargs):  # noqa: E501
        """Add a new ACL for a specified topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_acls_to_topic(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :param AclDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_acls_to_topic_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_acls_to_topic_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def add_acls_to_topic_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """Add a new ACL for a specified topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_acls_to_topic_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :param AclDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_acls_to_topic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `add_acls_to_topic`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `add_acls_to_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/acls', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_members(self, project_id, **kwargs):  # noqa: E501
        """add_members  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_members(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param MembersDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_members_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_members_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def add_members_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """add_members  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_members_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param MembersDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_members" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `add_members`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/projectMembers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_topic_schema(self, project_id, **kwargs):  # noqa: E501
        """add_topic_schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_topic_schema(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param SchemaDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_topic_schema_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_topic_schema_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def add_topic_schema_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """add_topic_schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_topic_schema_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param SchemaDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_topic_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `add_topic_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/schema/add', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def add_validation_rules(self, featuregroup_id, feature_store_id, project_id, **kwargs):  # noqa: E501
        """Write Deequ validation rules to Filesystem so validation job can pick it up  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_validation_rules(featuregroup_id, feature_store_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: (required)
        :param int feature_store_id: (required)
        :param int project_id: (required)
        :param ConstraintGroupDTO body:
        :return: DataValidationSettingsDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_validation_rules_with_http_info(featuregroup_id, feature_store_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.add_validation_rules_with_http_info(featuregroup_id, feature_store_id, project_id, **kwargs)  # noqa: E501
            return data

    def add_validation_rules_with_http_info(self, featuregroup_id, feature_store_id, project_id, **kwargs):  # noqa: E501
        """Write Deequ validation rules to Filesystem so validation job can pick it up  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_validation_rules_with_http_info(featuregroup_id, feature_store_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: (required)
        :param int feature_store_id: (required)
        :param int project_id: (required)
        :param ConstraintGroupDTO body:
        :return: DataValidationSettingsDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'feature_store_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_validation_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `add_validation_rules`")  # noqa: E501
        # verify the required parameter 'feature_store_id' is set
        if ('feature_store_id' not in params or
                params['feature_store_id'] is None):
            raise ValueError("Missing the required parameter `feature_store_id` when calling `add_validation_rules`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `add_validation_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'feature_store_id' in params:
            path_params['featureStoreId'] = params['feature_store_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featureStoreId}/datavalidation/{featuregroupId}/rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DataValidationSettingsDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_template(self, project_id, **kwargs):  # noqa: E501
        """attach_template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_template(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param FileTemplateDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_template_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_template_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def attach_template_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """attach_template  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_template_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param FileTemplateDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_template" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `attach_template`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/attachTemplate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_file_exist(self, path, project_id, **kwargs):  # noqa: E501
        """check_file_exist  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_file_exist(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_file_exist_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_file_exist_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def check_file_exist_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """check_file_exist  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_file_exist_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_file_exist" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `check_file_exist`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `check_file_exist`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/localfs/fileExists/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_file_exists(self, path, project_id, **kwargs):  # noqa: E501
        """check_file_exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_file_exists(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_file_exists_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_file_exists_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def check_file_exists_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """check_file_exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_file_exists_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_file_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `check_file_exists`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `check_file_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/fileExists/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_file_for_download(self, path, project_id, **kwargs):  # noqa: E501
        """check_file_for_download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_file_for_download(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_file_for_download_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_file_for_download_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def check_file_for_download_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """check_file_for_download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_file_for_download_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_file_for_download" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `check_file_for_download`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `check_file_for_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/checkFileForDownload/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def check_project_access(self, project_id, **kwargs):  # noqa: E501
        """check_project_access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_project_access(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.check_project_access_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.check_project_access_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def check_project_access_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """check_project_access  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.check_project_access_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method check_project_access" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `check_project_access`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/check', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def compose_dag(self, project_id, **kwargs):  # noqa: E501
        """Generate an Airflow Python DAG file from a DAG definition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compose_dag(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param AirflowDagDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.compose_dag_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.compose_dag_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def compose_dag_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Generate an Airflow Python DAG file from a DAG definition  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.compose_dag_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param AirflowDagDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method compose_dag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `compose_dag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/airflow/dag', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def convert_i_python_notebook(self, path, project_id, **kwargs):  # noqa: E501
        """convert_i_python_notebook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.convert_i_python_notebook(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.convert_i_python_notebook_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.convert_i_python_notebook_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def convert_i_python_notebook_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """convert_i_python_notebook  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.convert_i_python_notebook_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method convert_i_python_notebook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `convert_i_python_notebook`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `convert_i_python_notebook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/convertIPythonNotebook/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_file(self, project_id, **kwargs):  # noqa: E501
        """copy_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param MoveDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_file_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_file_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def copy_file_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """copy_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_file_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param MoveDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `copy_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def count_file_blocks(self, path, project_id, **kwargs):  # noqa: E501
        """count_file_blocks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_file_blocks(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.count_file_blocks_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.count_file_blocks_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def count_file_blocks_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """count_file_blocks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.count_file_blocks_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method count_file_blocks" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `count_file_blocks`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `count_file_blocks`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/countFileBlocks/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_data_set_dir(self, project_id, **kwargs):  # noqa: E501
        """create_data_set_dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_data_set_dir(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_data_set_dir_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_data_set_dir_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def create_data_set_dir_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """create_data_set_dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_data_set_dir_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_data_set_dir" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_data_set_dir`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_data_set_dir1(self, project_id, **kwargs):  # noqa: E501
        """create_data_set_dir1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_data_set_dir1(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_data_set_dir1_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_data_set_dir1_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def create_data_set_dir1_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """create_data_set_dir1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_data_set_dir1_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_data_set_dir1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_data_set_dir1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/localfs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_featuregroup(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Create feature group in a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_featuregroup(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturegroupDTO body:
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_featuregroup_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_featuregroup_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def create_featuregroup_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Create feature group in a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_featuregroup_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturegroupDTO body:
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_featuregroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `create_featuregroup`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_featuregroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturegroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_new_storage_connector_with_type(self, connector_type, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Create a new storage connector for the feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_storage_connector_with_type(connector_type, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturestoreStorageConnectorDTO body:
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_new_storage_connector_with_type_with_http_info(connector_type, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_new_storage_connector_with_type_with_http_info(connector_type, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def create_new_storage_connector_with_type_with_http_info(self, connector_type, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Create a new storage connector for the feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_new_storage_connector_with_type_with_http_info(connector_type, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturestoreStorageConnectorDTO body:
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_type', 'featurestore_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_new_storage_connector_with_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_type' is set
        if ('connector_type' not in params or
                params['connector_type'] is None):
            raise ValueError("Missing the required parameter `connector_type` when calling `create_new_storage_connector_with_type`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `create_new_storage_connector_with_type`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_new_storage_connector_with_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_type' in params:
            path_params['connectorType'] = params['connector_type']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors/{connectorType}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreStorageConnectorDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update(self, body, project_id, **kwargs):  # noqa: E501
        """Create or update a serving instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepresentsAServingModel body: serving specification (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_or_update_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def create_or_update_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Create or update a serving instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RepresentsAServingModel body: serving specification (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_or_update`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_or_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/serving', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_import_job(self, body, project_id, **kwargs):  # noqa: E501
        """Configure job to import featuregroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_import_job(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FeaturegroupImportJobDTO body: Job configuration (required)
        :param int project_id: (required)
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_or_update_import_job_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_import_job_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def create_or_update_import_job_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Configure job to import featuregroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_import_job_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param FeaturegroupImportJobDTO body: Job configuration (required)
        :param int project_id: (required)
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_import_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_or_update_import_job`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_or_update_import_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/importjob', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_training_dataset_job(self, body, project_id, **kwargs):  # noqa: E501
        """Configure job to create training dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_training_dataset_job(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TrainingDatasetJobDTO body: Job configuration (required)
        :param int project_id: (required)
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_or_update_training_dataset_job_with_http_info(body, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_training_dataset_job_with_http_info(body, project_id, **kwargs)  # noqa: E501
            return data

    def create_or_update_training_dataset_job_with_http_info(self, body, project_id, **kwargs):  # noqa: E501
        """Configure job to create training dataset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_training_dataset_job_with_http_info(body, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TrainingDatasetJobDTO body: Job configuration (required)
        :param int project_id: (required)
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_training_dataset_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_or_update_training_dataset_job`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_or_update_training_dataset_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/trainingdatasetjob', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_project(self, **kwargs):  # noqa: E501
        """create_project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_project_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_project_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_project_with_http_info(self, **kwargs):  # noqa: E501
        """create_project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_project_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProjectDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_project" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_top_level_data_set(self, project_id, **kwargs):  # noqa: E501
        """create_top_level_data_set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_top_level_data_set(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_top_level_data_set_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_top_level_data_set_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def create_top_level_data_set_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """create_top_level_data_set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_top_level_data_set_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_top_level_data_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_top_level_data_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/createTopLevelDataSet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_topic(self, project_id, **kwargs):  # noqa: E501
        """Create a new Kafka topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_topic(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param TopicDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_topic_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_topic_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def create_topic_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create a new Kafka topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_topic_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param TopicDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_topic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_training_dataset(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Create training dataset for a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_training_dataset(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param TrainingDatasetDTO body:
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_training_dataset_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_training_dataset_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def create_training_dataset_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Create training dataset for a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_training_dataset_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param TrainingDatasetDTO body:
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_training_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `create_training_dataset`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `create_training_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/trainingdatasets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrainingDatasetDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def credentials(self, project_id, **kwargs):  # noqa: E501
        """credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.credentials(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.credentials_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.credentials_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def credentials_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """credentials  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.credentials_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method credentials" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `credentials`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/credentials', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete(self, version, project_id, **kwargs):  # noqa: E501
        """Delete commands for this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_with_http_info(version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_with_http_info(version, project_id, **kwargs)  # noqa: E501
            return data

    def delete_with_http_info(self, version, project_id, **kwargs):  # noqa: E501
        """Delete commands for this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_with_http_info(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `delete`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/commands', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete1(self, library, version, project_id, **kwargs):  # noqa: E501
        """Delete commands for this library  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete1(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete1_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete1_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
            return data

    def delete1_with_http_info(self, library, version, project_id, **kwargs):  # noqa: E501
        """Delete commands for this library  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete1_with_http_info(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `delete1`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `delete1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}/commands', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete2(self, version, project_id, **kwargs):  # noqa: E501
        """Remove the python environment with the specified version for this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete2(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete2_with_http_info(version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete2_with_http_info(version, project_id, **kwargs)  # noqa: E501
            return data

    def delete2_with_http_info(self, version, project_id, **kwargs):  # noqa: E501
        """Remove the python environment with the specified version for this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete2_with_http_info(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `delete2`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnvironmentDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete3(self, name, project_id, **kwargs):  # noqa: E501
        """Delete the job with the given ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete3(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: id (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete3_with_http_info(name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete3_with_http_info(name, project_id, **kwargs)  # noqa: E501
            return data

    def delete3_with_http_info(self, name, project_id, **kwargs):  # noqa: E501
        """Delete the job with the given ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete3_with_http_info(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: id (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `delete3`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_feature_group_from_feature_store(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete specific featuregroup from a specific featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_feature_group_from_feature_store(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_feature_group_from_feature_store_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_feature_group_from_feature_store_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def delete_feature_group_from_feature_store_with_http_info(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete specific featuregroup from a specific featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_feature_group_from_feature_store_with_http_info(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_feature_group_from_feature_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `delete_feature_group_from_feature_store`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `delete_feature_group_from_feature_store`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_feature_group_from_feature_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/{featuregroupId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturegroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_featuregroup_contents(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete featuregroup contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_featuregroup_contents(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_featuregroup_contents_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_featuregroup_contents_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def delete_featuregroup_contents_with_http_info(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete featuregroup contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_featuregroup_contents_with_http_info(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_featuregroup_contents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `delete_featuregroup_contents`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `delete_featuregroup_contents`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_featuregroup_contents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/{featuregroupId}/clear', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturegroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_schema(self, schema_name, version, project_id, **kwargs):  # noqa: E501
        """delete_schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_schema(schema_name, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str schema_name: (required)
        :param int version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_schema_with_http_info(schema_name, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_schema_with_http_info(schema_name, version, project_id, **kwargs)  # noqa: E501
            return data

    def delete_schema_with_http_info(self, schema_name, version, project_id, **kwargs):  # noqa: E501
        """delete_schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_schema_with_http_info(schema_name, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str schema_name: (required)
        :param int version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['schema_name', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'schema_name' is set
        if ('schema_name' not in params or
                params['schema_name'] is None):
            raise ValueError("Missing the required parameter `schema_name` when calling `delete_schema`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `delete_schema`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'schema_name' in params:
            path_params['schemaName'] = params['schema_name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/removeSchema/{schemaName}/{version}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_serving(self, serving_id, project_id, **kwargs):  # noqa: E501
        """Delete a serving instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_serving(serving_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int serving_id: Id of the serving instance (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_serving_with_http_info(serving_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_serving_with_http_info(serving_id, project_id, **kwargs)  # noqa: E501
            return data

    def delete_serving_with_http_info(self, serving_id, project_id, **kwargs):  # noqa: E501
        """Delete a serving instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_serving_with_http_info(serving_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int serving_id: Id of the serving instance (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['serving_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_serving" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'serving_id' is set
        if ('serving_id' not in params or
                params['serving_id'] is None):
            raise ValueError("Missing the required parameter `serving_id` when calling `delete_serving`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_serving`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serving_id' in params:
            path_params['servingId'] = params['serving_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/serving/{servingId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_storage_connector_with_type_and_id(self, connector_type, connector_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete storage connector with a specific id and type from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_storage_connector_with_type_and_id(connector_type, connector_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int connector_id: Id of the storage connector (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_storage_connector_with_type_and_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_storage_connector_with_type_and_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def delete_storage_connector_with_type_and_id_with_http_info(self, connector_type, connector_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete storage connector with a specific id and type from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_storage_connector_with_type_and_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int connector_id: Id of the storage connector (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_type', 'connector_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_storage_connector_with_type_and_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_type' is set
        if ('connector_type' not in params or
                params['connector_type'] is None):
            raise ValueError("Missing the required parameter `connector_type` when calling `delete_storage_connector_with_type_and_id`")  # noqa: E501
        # verify the required parameter 'connector_id' is set
        if ('connector_id' not in params or
                params['connector_id'] is None):
            raise ValueError("Missing the required parameter `connector_id` when calling `delete_storage_connector_with_type_and_id`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `delete_storage_connector_with_type_and_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_storage_connector_with_type_and_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_type' in params:
            path_params['connectorType'] = params['connector_type']  # noqa: E501
        if 'connector_id' in params:
            path_params['connectorId'] = params['connector_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors/{connectorType}/{connectorId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreStorageConnectorDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_training_dataset(self, trainingdatasetid, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete a training datasets with a specific id from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_training_dataset(trainingdatasetid, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trainingdatasetid: Id of the training dataset (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_training_dataset_with_http_info(trainingdatasetid, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_training_dataset_with_http_info(trainingdatasetid, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def delete_training_dataset_with_http_info(self, trainingdatasetid, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Delete a training datasets with a specific id from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_training_dataset_with_http_info(trainingdatasetid, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trainingdatasetid: Id of the training dataset (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trainingdatasetid', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_training_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trainingdatasetid' is set
        if ('trainingdatasetid' not in params or
                params['trainingdatasetid'] is None):
            raise ValueError("Missing the required parameter `trainingdatasetid` when calling `delete_training_dataset`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `delete_training_dataset`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `delete_training_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trainingdatasetid' in params:
            path_params['trainingdatasetid'] = params['trainingdatasetid']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/trainingdatasets/{trainingdatasetid}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrainingDatasetDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_certs(self, project_id, **kwargs):  # noqa: E501
        """download_certs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_certs(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str password:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_certs_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_certs_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def download_certs_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """download_certs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_certs_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str password:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'password']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_certs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `download_certs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'password' in params:
            form_params.append(('password', params['password']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/downloadCert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_dataset_hdfs(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """download_dataset_hdfs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dataset_hdfs(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :param Download body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_dataset_hdfs_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_dataset_hdfs_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
            return data

    def download_dataset_hdfs_with_http_info(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """download_dataset_hdfs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dataset_hdfs_with_http_info(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :param Download body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_ds_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_dataset_hdfs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_ds_id' is set
        if ('public_ds_id' not in params or
                params['public_ds_id'] is None):
            raise ValueError("Missing the required parameter `public_ds_id` when calling `download_dataset_hdfs`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `download_dataset_hdfs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'public_ds_id' in params:
            path_params['publicDSId'] = params['public_ds_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/downloads/{publicDSId}/hdfs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_dataset_kafka(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """download_dataset_kafka  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dataset_kafka(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :param Download body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_dataset_kafka_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_dataset_kafka_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
            return data

    def download_dataset_kafka_with_http_info(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """download_dataset_kafka  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_dataset_kafka_with_http_info(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :param Download body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_ds_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_dataset_kafka" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_ds_id' is set
        if ('public_ds_id' not in params or
                params['public_ds_id'] is None):
            raise ValueError("Missing the required parameter `public_ds_id` when calling `download_dataset_kafka`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `download_dataset_kafka`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'public_ds_id' in params:
            path_params['publicDSId'] = params['public_ds_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/downloads/{publicDSId}/kafka', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_from_hdfs(self, path, project_id, **kwargs):  # noqa: E501
        """download_from_hdfs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_from_hdfs(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param str token:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_from_hdfs_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.download_from_hdfs_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def download_from_hdfs_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """download_from_hdfs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_from_hdfs_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param str token:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id', 'token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_from_hdfs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `download_from_hdfs`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `download_from_hdfs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'token' in params:
            query_params.append(('token', params['token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/fileDownload/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def example(self, type, **kwargs):  # noqa: E501
        """example  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.example(type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.example_with_http_info(type, **kwargs)  # noqa: E501
        else:
            (data) = self.example_with_http_info(type, **kwargs)  # noqa: E501
            return data

    def example_with_http_info(self, type, **kwargs):  # noqa: E501
        """example  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.example_with_http_info(type, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str type: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method example" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `example`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/starterProject/{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def execution(self, action, name, project_id, **kwargs):  # noqa: E501
        """Start/Stop a job  # noqa: E501

        Starts a job by creating and starting an Execution, stops a job by stopping the Execution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execution(action, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: start or stop (required)
        :param str name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.execution_with_http_info(action, name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.execution_with_http_info(action, name, project_id, **kwargs)  # noqa: E501
            return data

    def execution_with_http_info(self, action, name, project_id, **kwargs):  # noqa: E501
        """Start/Stop a job  # noqa: E501

        Starts a job by creating and starting an Execution, stops a job by stopping the Execution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.execution_with_http_info(action, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str action: start or stop (required)
        :param str name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['action', 'name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method execution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `execution`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `execution`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `execution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/executions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def file_preview(self, path, project_id, **kwargs):  # noqa: E501
        """file_preview  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.file_preview(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param str mode:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.file_preview_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.file_preview_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def file_preview_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """file_preview  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.file_preview_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param str mode:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id', 'mode']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method file_preview" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `file_preview`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `file_preview`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'mode' in params:
            query_params.append(('mode', params['mode']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/filePreview/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_all_by_id(self, activity_id, project_id, **kwargs):  # noqa: E501
        """Finds an activity in project.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_by_id(activity_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int activity_id: (required)
        :param int project_id: (required)
        :param list[str] expand: ex. expand=creator
        :return: ActivitiesDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_all_by_id_with_http_info(activity_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_all_by_id_with_http_info(activity_id, project_id, **kwargs)  # noqa: E501
            return data

    def find_all_by_id_with_http_info(self, activity_id, project_id, **kwargs):  # noqa: E501
        """Finds an activity in project.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_by_id_with_http_info(activity_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int activity_id: (required)
        :param int project_id: (required)
        :param list[str] expand: ex. expand=creator
        :return: ActivitiesDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['activity_id', 'project_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_all_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'activity_id' is set
        if ('activity_id' not in params or
                params['activity_id'] is None):
            raise ValueError("Missing the required parameter `activity_id` when calling `find_all_by_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `find_all_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'activity_id' in params:
            path_params['activityId'] = params['activity_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/activities/{activityId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActivitiesDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_all_by_project(self, project_id, **kwargs):  # noqa: E501
        """Finds activities in project.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_by_project(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,date_created:desc
        :param list[str] filter_by: ex. filter_by=flag:dataset
        :param list[str] expand: ex. expand=creator
        :return: ActivitiesDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_all_by_project_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_all_by_project_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def find_all_by_project_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Finds activities in project.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_by_project_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,date_created:desc
        :param list[str] filter_by: ex. filter_by=flag:dataset
        :param list[str] expand: ex. expand=creator
        :return: ActivitiesDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'offset', 'limit', 'sort_by', 'filter_by', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_all_by_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `find_all_by_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/activities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ActivitiesDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_all_by_user(self, **kwargs):  # noqa: E501
        """find_all_by_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_by_user(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_all_by_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.find_all_by_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def find_all_by_user_with_http_info(self, **kwargs):  # noqa: E501
        """find_all_by_user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_all_by_user_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_all_by_user" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_by_project_id(self, project_id, **kwargs):  # noqa: E501
        """find_by_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_project_id(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_by_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_by_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def find_by_project_id_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """find_by_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_by_project_id_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_by_project_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `find_by_project_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_data_sets_in_project_id(self, project_id, **kwargs):  # noqa: E501
        """find_data_sets_in_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_data_sets_in_project_id(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_data_sets_in_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_data_sets_in_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def find_data_sets_in_project_id_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """find_data_sets_in_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_data_sets_in_project_id_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_data_sets_in_project_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `find_data_sets_in_project_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/getContent', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_members_by_project_id(self, project_id, **kwargs):  # noqa: E501
        """find_members_by_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_members_by_project_id(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_members_by_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_members_by_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def find_members_by_project_id_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """find_members_by_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_members_by_project_id_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_members_by_project_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `find_members_by_project_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/projectMembers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get(self, version, project_id, **kwargs):  # noqa: E501
        """Get commands for this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,date_created:desc
        :param list[str] filter_by: ex. filter_by=op:create
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_with_http_info(version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_with_http_info(version, project_id, **kwargs)  # noqa: E501
            return data

    def get_with_http_info(self, version, project_id, **kwargs):  # noqa: E501
        """Get commands for this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_with_http_info(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,date_created:desc
        :param list[str] filter_by: ex. filter_by=op:create
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version', 'project_id', 'offset', 'limit', 'sort_by', 'filter_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/commands', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get1(self, library, version, project_id, **kwargs):  # noqa: E501
        """Get all commands for this library  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get1(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,date_created:desc
        :param list[str] filter_by: ex. filter_by=op:create
        :return: CommandDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get1_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get1_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
            return data

    def get1_with_http_info(self, library, version, project_id, **kwargs):  # noqa: E501
        """Get all commands for this library  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get1_with_http_info(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,date_created:desc
        :param list[str] filter_by: ex. filter_by=op:create
        :return: CommandDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'version', 'project_id', 'offset', 'limit', 'sort_by', 'filter_by']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `get1`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}/commands', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommandDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get2(self, version, project_id, **kwargs):  # noqa: E501
        """Get the python libraries installed in this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get2(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,dependency:desc
        :param list[str] filter_by: ex. filter_by=preinstalled:1
        :param list[str] expand: ex. expand=commands
        :return: LibraryDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get2_with_http_info(version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get2_with_http_info(version, project_id, **kwargs)  # noqa: E501
            return data

    def get2_with_http_info(self, version, project_id, **kwargs):  # noqa: E501
        """Get the python libraries installed in this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get2_with_http_info(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=ID:asc,dependency:desc
        :param list[str] filter_by: ex. filter_by=preinstalled:1
        :param list[str] expand: ex. expand=commands
        :return: LibraryDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version', 'project_id', 'offset', 'limit', 'sort_by', 'filter_by', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get2`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get3(self, version, project_id, **kwargs):  # noqa: E501
        """Get the python environment for specific python version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get3(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param list[str] expand: ex. expand=commands
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get3_with_http_info(version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get3_with_http_info(version, project_id, **kwargs)  # noqa: E501
            return data

    def get3_with_http_info(self, version, project_id, **kwargs):  # noqa: E501
        """Get the python environment for specific python version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get3_with_http_info(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param list[str] expand: ex. expand=commands
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version', 'project_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get3`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnvironmentDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all(self, project_id, **kwargs):  # noqa: E501
        """Get all python environments for this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param list[str] expand: ex. expand=commands
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_all_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get all python environments for this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param list[str] expand: ex. expand=commands
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_all`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnvironmentDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all1(self, project_id, **kwargs):  # noqa: E501
        """Get a list of all jobs for this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all1(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=date_created:desc,name:asc
        :param list[str] filter_by: ex. filter_by=jobtype:spark&filter_by=date_created_gt:2018-12-25T17:12:10
        :param list[str] expand: ex. expand=creator
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all1_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all1_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_all1_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get a list of all jobs for this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all1_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=date_created:desc,name:asc
        :param list[str] filter_by: ex. filter_by=jobtype:spark&filter_by=date_created_gt:2018-12-25T17:12:10
        :param list[str] expand: ex. expand=creator
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'offset', 'limit', 'sort_by', 'filter_by', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_all1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_notebook_servers_in_project(self, project_id, **kwargs):  # noqa: E501
        """get_all_notebook_servers_in_project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_notebook_servers_in_project(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_notebook_servers_in_project_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_notebook_servers_in_project_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_all_notebook_servers_in_project_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_all_notebook_servers_in_project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_notebook_servers_in_project_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_notebook_servers_in_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_all_notebook_servers_in_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_projects(self, **kwargs):  # noqa: E501
        """get_all_projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_projects(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_projects_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_projects_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_projects_with_http_info(self, **kwargs):  # noqa: E501
        """get_all_projects  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_projects_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_projects" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/getAll', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_app_info(self, app_id, project_id, **kwargs):  # noqa: E501
        """get_app_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_app_info(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_app_info_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_app_info_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_app_info_with_http_info(self, app_id, project_id, **kwargs):  # noqa: E501
        """get_app_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_app_info_with_http_info(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_app_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_app_info`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_app_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{appId}/appinfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_by_name(self, command_id, version, project_id, **kwargs):  # noqa: E501
        """Get commands by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_name(command_id, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int command_id: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: CommandDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_by_name_with_http_info(command_id, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_by_name_with_http_info(command_id, version, project_id, **kwargs)  # noqa: E501
            return data

    def get_by_name_with_http_info(self, command_id, version, project_id, **kwargs):  # noqa: E501
        """Get commands by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_name_with_http_info(command_id, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int command_id: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: CommandDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['command_id', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'command_id' is set
        if ('command_id' not in params or
                params['command_id'] is None):
            raise ValueError("Missing the required parameter `command_id` when calling `get_by_name`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_by_name`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'command_id' in params:
            path_params['commandId'] = params['command_id']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/commands/{commandId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommandDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_by_name1(self, library, command_id, version, project_id, **kwargs):  # noqa: E501
        """Get command by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_name1(library, command_id, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param int command_id: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: CommandDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_by_name1_with_http_info(library, command_id, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_by_name1_with_http_info(library, command_id, version, project_id, **kwargs)  # noqa: E501
            return data

    def get_by_name1_with_http_info(self, library, command_id, version, project_id, **kwargs):  # noqa: E501
        """Get command by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_name1_with_http_info(library, command_id, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param int command_id: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: CommandDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'command_id', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_by_name1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `get_by_name1`")  # noqa: E501
        # verify the required parameter 'command_id' is set
        if ('command_id' not in params or
                params['command_id'] is None):
            raise ValueError("Missing the required parameter `command_id` when calling `get_by_name1`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_by_name1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_by_name1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'command_id' in params:
            path_params['commandId'] = params['command_id']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}/commands/{commandId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CommandDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_by_name2(self, library, version, project_id, **kwargs):  # noqa: E501
        """Get the a python library installed in this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_name2(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :param list[str] expand: ex. expand=commands
        :return: LibraryDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_by_name2_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_by_name2_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
            return data

    def get_by_name2_with_http_info(self, library, version, project_id, **kwargs):  # noqa: E501
        """Get the a python library installed in this environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_by_name2_with_http_info(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :param list[str] expand: ex. expand=commands
        :return: LibraryDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'version', 'project_id', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_by_name2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `get_by_name2`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `get_by_name2`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_by_name2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibraryDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_current_multiplicator(self, project_id, **kwargs):  # noqa: E501
        """get_current_multiplicator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_multiplicator(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_current_multiplicator_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_current_multiplicator_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_current_multiplicator_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_current_multiplicator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_current_multiplicator_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_current_multiplicator" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_current_multiplicator`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/multiplicators', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_info(self, inode_id, **kwargs):  # noqa: E501
        """get_dataset_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_info(inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dataset_info_with_http_info(inode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dataset_info_with_http_info(inode_id, **kwargs)  # noqa: E501
            return data

    def get_dataset_info_with_http_info(self, inode_id, **kwargs):  # noqa: E501
        """get_dataset_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_info_with_http_info(inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `get_dataset_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/getDatasetInfo/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dataset_info1(self, project_id, inode_id, **kwargs):  # noqa: E501
        """get_dataset_info1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_info1(project_id, inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dataset_info1_with_http_info(project_id, inode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dataset_info1_with_http_info(project_id, inode_id, **kwargs)  # noqa: E501
            return data

    def get_dataset_info1_with_http_info(self, project_id, inode_id, **kwargs):  # noqa: E501
        """get_dataset_info1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dataset_info1_with_http_info(project_id, inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'inode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dataset_info1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_dataset_info1`")  # noqa: E501
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `get_dataset_info1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/getInodeInfo/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_dir_content(self, path, project_id, **kwargs):  # noqa: E501
        """get_dir_content  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dir_content(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_dir_content_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_dir_content_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def get_dir_content_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """get_dir_content  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_dir_content_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_dir_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_dir_content`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_dir_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/getContent/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_execution(self, id, name, project_id, **kwargs):  # noqa: E501
        """Find Execution by Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_execution(id, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: execution id (required)
        :param str name: (required)
        :param int project_id: (required)
        :param str sort_by: ex. sort_by=submissiontime:desc,id:asc
        :param list[str] filter_by: state and finalstatus accept also neq (not equals) ex. filter_by=state:running&filter_by=state_neq:new&filter_by=submissiontime:2018-12-25T17:12:10.058
        :param list[str] expand: ex. expand=creator
        :return: ExecutionDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_execution_with_http_info(id, name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_execution_with_http_info(id, name, project_id, **kwargs)  # noqa: E501
            return data

    def get_execution_with_http_info(self, id, name, project_id, **kwargs):  # noqa: E501
        """Find Execution by Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_execution_with_http_info(id, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: execution id (required)
        :param str name: (required)
        :param int project_id: (required)
        :param str sort_by: ex. sort_by=submissiontime:desc,id:asc
        :param list[str] filter_by: state and finalstatus accept also neq (not equals) ex. filter_by=state:running&filter_by=state_neq:new&filter_by=submissiontime:2018-12-25T17:12:10.058
        :param list[str] expand: ex. expand=creator
        :return: ExecutionDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'name', 'project_id', 'sort_by', 'filter_by', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_execution" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_execution`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_execution`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_execution`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/executions/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExecutionDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_executions(self, name, project_id, **kwargs):  # noqa: E501
        """Get a list of executions for the job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_executions(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=submissiontime:desc,id:asc
        :param list[str] filter_by: state and finalstatus accept also neq (not equals) ex. filter_by=state:running&filter_by=state_neq:new&filter_by=submissiontime:2018-12-25T17:12:10.058
        :param list[str] expand: ex. expand=creator
        :return: ExecutionDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_executions_with_http_info(name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_executions_with_http_info(name, project_id, **kwargs)  # noqa: E501
            return data

    def get_executions_with_http_info(self, name, project_id, **kwargs):  # noqa: E501
        """Get a list of executions for the job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_executions_with_http_info(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :param int offset:
        :param int limit:
        :param str sort_by: ex. sort_by=submissiontime:desc,id:asc
        :param list[str] filter_by: state and finalstatus accept also neq (not equals) ex. filter_by=state:running&filter_by=state_neq:new&filter_by=submissiontime:2018-12-25T17:12:10.058
        :param list[str] expand: ex. expand=creator
        :return: ExecutionDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id', 'offset', 'limit', 'sort_by', 'filter_by', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_executions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_executions`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_executions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/executions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ExecutionDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_extended_details(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """get_extended_details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_extended_details(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_extended_details_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_extended_details_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_extended_details_with_http_info(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """get_extended_details  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_extended_details_with_http_info(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_ds_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_extended_details" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_ds_id' is set
        if ('public_ds_id' not in params or
                params['public_ds_id'] is None):
            raise ValueError("Missing the required parameter `public_ds_id` when calling `get_extended_details`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_extended_details`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'public_ds_id' in params:
            path_params['publicDSId'] = params['public_ds_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/transfers/{publicDSId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feature_group_from_feature_store(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get specific featuregroup from a specific featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_group_from_feature_store(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_feature_group_from_feature_store_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_feature_group_from_feature_store_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_feature_group_from_feature_store_with_http_info(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get specific featuregroup from a specific featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_group_from_feature_store_with_http_info(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feature_group_from_feature_store" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `get_feature_group_from_feature_store`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_feature_group_from_feature_store`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_feature_group_from_feature_store`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/{featuregroupId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturegroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feature_group_preview(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Preview feature data of a featuregroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_group_preview(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturegroupPreview]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_feature_group_preview_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_feature_group_preview_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_feature_group_preview_with_http_info(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Preview feature data of a featuregroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_group_preview_with_http_info(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturegroupPreview]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feature_group_preview" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `get_feature_group_preview`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_feature_group_preview`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_feature_group_preview`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/{featuregroupId}/preview', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeaturegroupPreview]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_feature_group_schema(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get the SQL schema of a featuregroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_group_schema(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: RowValueQueryResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_feature_group_schema_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_feature_group_schema_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_feature_group_schema_with_http_info(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get the SQL schema of a featuregroup  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_feature_group_schema_with_http_info(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: RowValueQueryResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_feature_group_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `get_feature_group_schema`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_feature_group_schema`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_feature_group_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/{featuregroupId}/schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RowValueQueryResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_featuregroups_for_featurestore(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get the list of feature groups for a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featuregroups_for_featurestore(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturegroupDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_featuregroups_for_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_featuregroups_for_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_featuregroups_for_featurestore_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get the list of feature groups for a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featuregroups_for_featurestore_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturegroupDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_featuregroups_for_featurestore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_featuregroups_for_featurestore`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_featuregroups_for_featurestore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeaturegroupDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_featurestore(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get featurestore with specific Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: Id of the featurestore (required)
        :param int project_id: (required)
        :return: FeaturestoreDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_featurestore_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get featurestore with specific Id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: Id of the featurestore (required)
        :param int project_id: (required)
        :return: FeaturestoreDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_featurestore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_featurestore`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_featurestore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_featurestore_by_name(self, featurestore_name, project_id, **kwargs):  # noqa: E501
        """Get featurestore with specific name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_by_name(featurestore_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str featurestore_name: Id of the featurestore (required)
        :param int project_id: (required)
        :return: FeaturestoreDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_featurestore_by_name_with_http_info(featurestore_name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_featurestore_by_name_with_http_info(featurestore_name, project_id, **kwargs)  # noqa: E501
            return data

    def get_featurestore_by_name_with_http_info(self, featurestore_name, project_id, **kwargs):  # noqa: E501
        """Get featurestore with specific name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_by_name_with_http_info(featurestore_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str featurestore_name: Id of the featurestore (required)
        :param int project_id: (required)
        :return: FeaturestoreDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_featurestore_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_name' is set
        if ('featurestore_name' not in params or
                params['featurestore_name'] is None):
            raise ValueError("Missing the required parameter `featurestore_name` when calling `get_featurestore_by_name`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_featurestore_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_name' in params:
            path_params['featurestoreName'] = params['featurestore_name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/getByName/{featurestoreName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_featurestore_id(self, featurestore_name, project_id, **kwargs):  # noqa: E501
        """Get featurestore Metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_id(featurestore_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str featurestore_name: (required)
        :param int project_id: (required)
        :return: FeaturestoreClientSettingsDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_featurestore_id_with_http_info(featurestore_name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_featurestore_id_with_http_info(featurestore_name, project_id, **kwargs)  # noqa: E501
            return data

    def get_featurestore_id_with_http_info(self, featurestore_name, project_id, **kwargs):  # noqa: E501
        """Get featurestore Metadata  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_id_with_http_info(featurestore_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str featurestore_name: (required)
        :param int project_id: (required)
        :return: FeaturestoreClientSettingsDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_featurestore_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_name' is set
        if ('featurestore_name' not in params or
                params['featurestore_name'] is None):
            raise ValueError("Missing the required parameter `featurestore_name` when calling `get_featurestore_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_featurestore_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_name' in params:
            path_params['featurestoreName'] = params['featurestore_name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreName}/metadata', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreClientSettingsDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_featurestore_settings(self, project_id, **kwargs):  # noqa: E501
        """Get featurestore settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_settings(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: FeaturestoreClientSettingsDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_featurestore_settings_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_featurestore_settings_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_featurestore_settings_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get featurestore settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestore_settings_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: FeaturestoreClientSettingsDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_featurestore_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_featurestore_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreClientSettingsDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_featurestores(self, project_id, **kwargs):  # noqa: E501
        """Get the list of feature stores for the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestores(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: list[FeaturestoreDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_featurestores_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_featurestores_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_featurestores_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get the list of feature stores for the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_featurestores_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: list[FeaturestoreDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_featurestores" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_featurestores`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeaturestoreDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_file(self, path, project_id, **kwargs):  # noqa: E501
        """get_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_file_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_file_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def get_file_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """get_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_file_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `get_file`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/getFile/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_git_status_of_jupyter_repo(self, project_id, **kwargs):  # noqa: E501
        """get_git_status_of_jupyter_repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_git_status_of_jupyter_repo(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_git_status_of_jupyter_repo_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_git_status_of_jupyter_repo_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_git_status_of_jupyter_repo_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_git_status_of_jupyter_repo  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_git_status_of_jupyter_repo_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_git_status_of_jupyter_repo" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_git_status_of_jupyter_repo`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/git/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job(self, name, project_id, **kwargs):  # noqa: E501
        """Get the job with requested ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :param str sort_by: ex. sort_by=date_created:desc,name:asc
        :param list[str] filter_by: ex. filter_by=jobtype:spark&filter_by=date_created_gt:2018-12-25T17:12:10
        :param list[str] expand: ex. expand=creator
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_with_http_info(name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_with_http_info(name, project_id, **kwargs)  # noqa: E501
            return data

    def get_job_with_http_info(self, name, project_id, **kwargs):  # noqa: E501
        """Get the job with requested ID  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_with_http_info(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :param str sort_by: ex. sort_by=date_created:desc,name:asc
        :param list[str] filter_by: ex. filter_by=jobtype:spark&filter_by=date_created_gt:2018-12-25T17:12:10
        :param list[str] expand: ex. expand=creator
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id', 'sort_by', 'filter_by', 'expand']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_job`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'sort_by' in params:
            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
        if 'filter_by' in params:
            query_params.append(('filter_by', params['filter_by']))  # noqa: E501
            collection_formats['filter_by'] = 'multi'  # noqa: E501
        if 'expand' in params:
            query_params.append(('expand', params['expand']))  # noqa: E501
            collection_formats['expand'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_job_ui(self, app_id, is_livy, project_id, **kwargs):  # noqa: E501
        """get_job_ui  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_ui(app_id, is_livy, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str is_livy: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_job_ui_with_http_info(app_id, is_livy, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_job_ui_with_http_info(app_id, is_livy, project_id, **kwargs)  # noqa: E501
            return data

    def get_job_ui_with_http_info(self, app_id, is_livy, project_id, **kwargs):  # noqa: E501
        """get_job_ui  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_job_ui_with_http_info(app_id, is_livy, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param str is_livy: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'is_livy', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_job_ui" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_job_ui`")  # noqa: E501
        # verify the required parameter 'is_livy' is set
        if ('is_livy' not in params or
                params['is_livy'] is None):
            raise ValueError("Missing the required parameter `is_livy` when calling `get_job_ui`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_job_ui`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'is_livy' in params:
            path_params['isLivy'] = params['is_livy']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{appId}/ui/{isLivy}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_log(self, id, type, name, project_id, **kwargs):  # noqa: E501
        """Retrieve log of given execution and type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log(id, type, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str type: (required)
        :param str name: (required)
        :param int project_id: (required)
        :return: JobLogDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_log_with_http_info(id, type, name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_log_with_http_info(id, type, name, project_id, **kwargs)  # noqa: E501
            return data

    def get_log_with_http_info(self, id, type, name, project_id, **kwargs):  # noqa: E501
        """Retrieve log of given execution and type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_log_with_http_info(id, type, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str type: (required)
        :param str name: (required)
        :param int project_id: (required)
        :return: JobLogDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'type', 'name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_log`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `get_log`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_log`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/executions/{id}/log/{type}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobLogDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_more_info(self, project_id, inode_id, **kwargs):  # noqa: E501
        """get_more_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_more_info(project_id, inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_more_info_with_http_info(project_id, inode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_more_info_with_http_info(project_id, inode_id, **kwargs)  # noqa: E501
            return data

    def get_more_info_with_http_info(self, project_id, inode_id, **kwargs):  # noqa: E501
        """get_more_info  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_more_info_with_http_info(project_id, inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'inode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_more_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_more_info`")  # noqa: E501
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `get_more_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/getMoreInfo/{type}/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_more_info1(self, inode_id, **kwargs):  # noqa: E501
        """get_more_info1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_more_info1(inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_more_info1_with_http_info(inode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_more_info1_with_http_info(inode_id, **kwargs)  # noqa: E501
            return data

    def get_more_info1_with_http_info(self, inode_id, **kwargs):  # noqa: E501
        """get_more_info1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_more_info1_with_http_info(inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_more_info1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `get_more_info1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/getMoreInfo/{type}/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_more_info2(self, project_id, **kwargs):  # noqa: E501
        """get_more_info2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_more_info2(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_more_info2_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_more_info2_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_more_info2_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_more_info2  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_more_info2_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_more_info2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_more_info2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/getMoreInfo/proj/{projectId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_online_featurestore_storage_connector(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get online featurestore storage connector for this feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_online_featurestore_storage_connector(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_online_featurestore_storage_connector_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_online_featurestore_storage_connector_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_online_featurestore_storage_connector_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get online featurestore storage connector for this feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_online_featurestore_storage_connector_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_online_featurestore_storage_connector" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_online_featurestore_storage_connector`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_online_featurestore_storage_connector`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors/onlinefeaturestore', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreStorageConnectorDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_pia(self, project_id, **kwargs):  # noqa: E501
        """get_pia  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pia(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_pia_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_pia_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_pia_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_pia  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_pia_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_pia" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_pia`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/pia', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_by_name(self, project_name, **kwargs):  # noqa: E501
        """get_project_by_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_by_name(project_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_by_name_with_http_info(project_name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_by_name_with_http_info(project_name, **kwargs)  # noqa: E501
            return data

    def get_project_by_name_with_http_info(self, project_name, **kwargs):  # noqa: E501
        """get_project_by_name  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_by_name_with_http_info(project_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str project_name: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_by_name" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params or
                params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `get_project_by_name`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/getProjectInfo/{projectName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_contents(self, project_id, **kwargs):  # noqa: E501
        """get_project_contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_contents(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_contents_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_contents_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_project_contents_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_project_contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_contents_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_contents" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project_contents`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/transfers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_project_shared_with(self, project_id, **kwargs):  # noqa: E501
        """get_project_shared_with  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_shared_with(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_project_shared_with_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_project_shared_with_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_project_shared_with_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_project_shared_with  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_project_shared_with_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_project_shared_with" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_project_shared_with`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/projectsSharedWith', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_readme_by_inode_id(self, inode_id, **kwargs):  # noqa: E501
        """get_readme_by_inode_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_readme_by_inode_id(inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_readme_by_inode_id_with_http_info(inode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_readme_by_inode_id_with_http_info(inode_id, **kwargs)  # noqa: E501
            return data

    def get_readme_by_inode_id_with_http_info(self, inode_id, **kwargs):  # noqa: E501
        """get_readme_by_inode_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_readme_by_inode_id_with_http_info(inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_readme_by_inode_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `get_readme_by_inode_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/readme/byInodeId/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_remote_git_branches(self, project_id, **kwargs):  # noqa: E501
        """get_remote_git_branches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remote_git_branches(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str remote_uri:
        :param str key_name:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_remote_git_branches_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_remote_git_branches_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_remote_git_branches_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """get_remote_git_branches  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_remote_git_branches_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str remote_uri:
        :param str key_name:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'remote_uri', 'key_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_remote_git_branches" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_remote_git_branches`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'remote_uri' in params:
            query_params.append(('remoteURI', params['remote_uri']))  # noqa: E501
        if 'key_name' in params:
            query_params.append(('keyName', params['key_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/git/branches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_schema(self, topic, project_id, **kwargs):  # noqa: E501
        """get_schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_schema(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_schema_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_schema_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def get_schema_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """get_schema  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_schema_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_schema" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `get_schema`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_schema`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/{topic}/schema', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_schema_content(self, schema_name, schema_version, project_id, **kwargs):  # noqa: E501
        """get_schema_content  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_schema_content(schema_name, schema_version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str schema_name: (required)
        :param int schema_version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_schema_content_with_http_info(schema_name, schema_version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_schema_content_with_http_info(schema_name, schema_version, project_id, **kwargs)  # noqa: E501
            return data

    def get_schema_content_with_http_info(self, schema_name, schema_version, project_id, **kwargs):  # noqa: E501
        """get_schema_content  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_schema_content_with_http_info(schema_name, schema_version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str schema_name: (required)
        :param int schema_version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['schema_name', 'schema_version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_schema_content" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'schema_name' is set
        if ('schema_name' not in params or
                params['schema_name'] is None):
            raise ValueError("Missing the required parameter `schema_name` when calling `get_schema_content`")  # noqa: E501
        # verify the required parameter 'schema_version' is set
        if ('schema_version' not in params or
                params['schema_version'] is None):
            raise ValueError("Missing the required parameter `schema_version` when calling `get_schema_content`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_schema_content`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'schema_name' in params:
            path_params['schemaName'] = params['schema_name']  # noqa: E501
        if 'schema_version' in params:
            path_params['schemaVersion'] = params['schema_version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/showSchema/{schemaName}/{schemaVersion}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_serving(self, serving_id, project_id, **kwargs):  # noqa: E501
        """Get info about a serving instance for the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_serving(serving_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int serving_id: Id of the Serving instance (required)
        :param int project_id: (required)
        :return: RepresentsAServingModel
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_serving_with_http_info(serving_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_serving_with_http_info(serving_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_serving_with_http_info(self, serving_id, project_id, **kwargs):  # noqa: E501
        """Get info about a serving instance for the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_serving_with_http_info(serving_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int serving_id: Id of the Serving instance (required)
        :param int project_id: (required)
        :return: RepresentsAServingModel
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['serving_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_serving" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'serving_id' is set
        if ('serving_id' not in params or
                params['serving_id'] is None):
            raise ValueError("Missing the required parameter `serving_id` when calling `get_serving`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_serving`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serving_id' in params:
            path_params['servingId'] = params['serving_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/serving/{servingId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RepresentsAServingModel',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_servings(self, project_id, **kwargs):  # noqa: E501
        """Get the list of serving instances for the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_servings(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: list[RepresentsAServingModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_servings_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_servings_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_servings_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get the list of serving instances for the project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_servings_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: list[RepresentsAServingModel]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_servings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_servings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/serving', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[RepresentsAServingModel]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_storage_connector_with_id(self, connector_type, connector_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get a storage connector with a specific id and type from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_connector_with_id(connector_type, connector_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int connector_id: Id of the storage connector (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_storage_connector_with_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_storage_connector_with_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_storage_connector_with_id_with_http_info(self, connector_type, connector_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get a storage connector with a specific id and type from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_connector_with_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int connector_id: Id of the storage connector (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_type', 'connector_id', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_storage_connector_with_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_type' is set
        if ('connector_type' not in params or
                params['connector_type'] is None):
            raise ValueError("Missing the required parameter `connector_type` when calling `get_storage_connector_with_id`")  # noqa: E501
        # verify the required parameter 'connector_id' is set
        if ('connector_id' not in params or
                params['connector_id'] is None):
            raise ValueError("Missing the required parameter `connector_id` when calling `get_storage_connector_with_id`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_storage_connector_with_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_storage_connector_with_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_type' in params:
            path_params['connectorType'] = params['connector_type']  # noqa: E501
        if 'connector_id' in params:
            path_params['connectorId'] = params['connector_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors/{connectorType}/{connectorId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreStorageConnectorDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_storage_connectors(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get all storage connectors of a feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_connectors(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturestoreStorageConnectorDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_storage_connectors_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_storage_connectors_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_storage_connectors_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get all storage connectors of a feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_connectors_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturestoreStorageConnectorDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_storage_connectors" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_storage_connectors`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_storage_connectors`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeaturestoreStorageConnectorDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_storage_connectors_of_type(self, connector_type, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get all storage connectors of a specific type of a feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_connectors_of_type(connector_type, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturestoreStorageConnectorDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_storage_connectors_of_type_with_http_info(connector_type, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_storage_connectors_of_type_with_http_info(connector_type, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_storage_connectors_of_type_with_http_info(self, connector_type, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get all storage connectors of a specific type of a feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_storage_connectors_of_type_with_http_info(connector_type, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[FeaturestoreStorageConnectorDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_type', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_storage_connectors_of_type" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_type' is set
        if ('connector_type' not in params or
                params['connector_type'] is None):
            raise ValueError("Missing the required parameter `connector_type` when calling `get_storage_connectors_of_type`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_storage_connectors_of_type`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_storage_connectors_of_type`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_type' in params:
            path_params['connectorType'] = params['connector_type']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors/{connectorType}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[FeaturestoreStorageConnectorDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tensor_board(self, project_id, **kwargs):  # noqa: E501
        """Get the running TensorBoard of the logged in user in this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tensor_board(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tensor_board_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tensor_board_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_tensor_board_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Get the running TensorBoard of the logged in user in this project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tensor_board_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tensor_board" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_tensor_board`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/tensorboard', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_tensor_board_urls(self, app_id, project_id, **kwargs):  # noqa: E501
        """get_tensor_board_urls  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tensor_board_urls(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_tensor_board_urls_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_tensor_board_urls_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_tensor_board_urls_with_http_info(self, app_id, project_id, **kwargs):  # noqa: E501
        """get_tensor_board_urls  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_tensor_board_urls_with_http_info(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_tensor_board_urls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_tensor_board_urls`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_tensor_board_urls`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{appId}/tensorboard', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topic(self, topic, project_id, **kwargs):  # noqa: E501
        """Get Kafka topic details.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topic(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topic_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_topic_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def get_topic_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """Get Kafka topic details.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topic_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `get_topic`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topic_acl(self, topic, id, project_id, **kwargs):  # noqa: E501
        """Get ACL metadata specified by id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topic_acl(topic, id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topic_acl_with_http_info(topic, id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_topic_acl_with_http_info(topic, id, project_id, **kwargs)  # noqa: E501
            return data

    def get_topic_acl_with_http_info(self, topic, id, project_id, **kwargs):  # noqa: E501
        """Get ACL metadata specified by id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topic_acl_with_http_info(topic, id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topic_acl" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `get_topic_acl`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_topic_acl`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_topic_acl`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/acls/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topic_acls(self, topic, project_id, **kwargs):  # noqa: E501
        """Get all ACLs for a specified topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topic_acls(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :param AclsBeanParam body:
        :param int offset:
        :param int limit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topic_acls_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_topic_acls_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def get_topic_acls_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """Get all ACLs for a specified topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topic_acls_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :param AclsBeanParam body:
        :param int offset:
        :param int limit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id', 'body', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topic_acls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `get_topic_acls`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_topic_acls`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/acls', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_topics(self, project_id, **kwargs):  # noqa: E501
        """Retrieve Kafka topics metadata .  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topics(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param TopicsBeanParam body:
        :param int offset:
        :param int limit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_topics_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_topics_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def get_topics_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Retrieve Kafka topics metadata .  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_topics_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param TopicsBeanParam body:
        :param int offset:
        :param int limit:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_topics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_topics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_training_dataset_with_id(self, trainingdatasetid, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get a training datasets with a specific id from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_training_dataset_with_id(trainingdatasetid, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trainingdatasetid: Id of the training dataset (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_training_dataset_with_id_with_http_info(trainingdatasetid, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_training_dataset_with_id_with_http_info(trainingdatasetid, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_training_dataset_with_id_with_http_info(self, trainingdatasetid, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get a training datasets with a specific id from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_training_dataset_with_id_with_http_info(trainingdatasetid, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trainingdatasetid: Id of the training dataset (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trainingdatasetid', 'featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_training_dataset_with_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trainingdatasetid' is set
        if ('trainingdatasetid' not in params or
                params['trainingdatasetid'] is None):
            raise ValueError("Missing the required parameter `trainingdatasetid` when calling `get_training_dataset_with_id`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_training_dataset_with_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_training_dataset_with_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trainingdatasetid' in params:
            path_params['trainingdatasetid'] = params['trainingdatasetid']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/trainingdatasets/{trainingdatasetid}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrainingDatasetDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_training_datasets_for_featurestore(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get the list of training datasets for a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_training_datasets_for_featurestore(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[TrainingDatasetDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_training_datasets_for_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_training_datasets_for_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_training_datasets_for_featurestore_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get the list of training datasets for a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_training_datasets_for_featurestore_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :return: list[TrainingDatasetDTO]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_training_datasets_for_featurestore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `get_training_datasets_for_featurestore`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_training_datasets_for_featurestore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/trainingdatasets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[TrainingDatasetDTO]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_validation_result(self, featuregroup_id, feature_store_id, project_id, **kwargs):  # noqa: E501
        """Fetch the result of a Deequ data validation job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_validation_result(featuregroup_id, feature_store_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: (required)
        :param int feature_store_id: (required)
        :param int project_id: (required)
        :return: ValidationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_validation_result_with_http_info(featuregroup_id, feature_store_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_validation_result_with_http_info(featuregroup_id, feature_store_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_validation_result_with_http_info(self, featuregroup_id, feature_store_id, project_id, **kwargs):  # noqa: E501
        """Fetch the result of a Deequ data validation job  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_validation_result_with_http_info(featuregroup_id, feature_store_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: (required)
        :param int feature_store_id: (required)
        :param int project_id: (required)
        :return: ValidationResult
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'feature_store_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_validation_result" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `get_validation_result`")  # noqa: E501
        # verify the required parameter 'feature_store_id' is set
        if ('feature_store_id' not in params or
                params['feature_store_id'] is None):
            raise ValueError("Missing the required parameter `feature_store_id` when calling `get_validation_result`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_validation_result`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'feature_store_id' in params:
            path_params['featureStoreId'] = params['feature_store_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featureStoreId}/datavalidation/{featuregroupId}/result', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ValidationResult',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_validation_rules(self, featuregroup_id, feature_store_id, project_id, **kwargs):  # noqa: E501
        """Get previously stored Deequ validation rules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_validation_rules(featuregroup_id, feature_store_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: (required)
        :param int feature_store_id: (required)
        :param int project_id: (required)
        :return: ConstraintGroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_validation_rules_with_http_info(featuregroup_id, feature_store_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_validation_rules_with_http_info(featuregroup_id, feature_store_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_validation_rules_with_http_info(self, featuregroup_id, feature_store_id, project_id, **kwargs):  # noqa: E501
        """Get previously stored Deequ validation rules  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_validation_rules_with_http_info(featuregroup_id, feature_store_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: (required)
        :param int feature_store_id: (required)
        :param int project_id: (required)
        :return: ConstraintGroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'feature_store_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_validation_rules" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `get_validation_rules`")  # noqa: E501
        # verify the required parameter 'feature_store_id' is set
        if ('feature_store_id' not in params or
                params['feature_store_id'] is None):
            raise ValueError("Missing the required parameter `feature_store_id` when calling `get_validation_rules`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_validation_rules`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'feature_store_id' in params:
            path_params['featureStoreId'] = params['feature_store_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featureStoreId}/datavalidation/{featuregroupId}/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ConstraintGroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_yarn_ui(self, app_id, project_id, **kwargs):  # noqa: E501
        """get_yarn_ui  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_yarn_ui(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_yarn_ui_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_yarn_ui_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
            return data

    def get_yarn_ui_with_http_info(self, app_id, project_id, **kwargs):  # noqa: E501
        """get_yarn_ui  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_yarn_ui_with_http_info(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_yarn_ui" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `get_yarn_ui`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `get_yarn_ui`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{appId}/yarnui', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def infer(self, model_name, version, verb, project_id, **kwargs):  # noqa: E501
        """Make inference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.infer(model_name, version, verb, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_name: Name of the model to query (required)
        :param str version: Version of the model to query (required)
        :param str verb: Type of query (required)
        :param int project_id: (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.infer_with_http_info(model_name, version, verb, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.infer_with_http_info(model_name, version, verb, project_id, **kwargs)  # noqa: E501
            return data

    def infer_with_http_info(self, model_name, version, verb, project_id, **kwargs):  # noqa: E501
        """Make inference  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.infer_with_http_info(model_name, version, verb, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str model_name: Name of the model to query (required)
        :param str version: Version of the model to query (required)
        :param str verb: Type of query (required)
        :param int project_id: (required)
        :param str body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['model_name', 'version', 'verb', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method infer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'model_name' is set
        if ('model_name' not in params or
                params['model_name'] is None):
            raise ValueError("Missing the required parameter `model_name` when calling `infer`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `infer`")  # noqa: E501
        # verify the required parameter 'verb' is set
        if ('verb' not in params or
                params['verb'] is None):
            raise ValueError("Missing the required parameter `verb` when calling `infer`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `infer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'model_name' in params:
            path_params['modelName'] = params['model_name']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'verb' in params:
            path_params['verb'] = params['verb']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/inference/models/{modelName}{version}{verb}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def inspect(self, jobtype, path, project_id, **kwargs):  # noqa: E501
        """Inspect Spark user program and return SparkJobConfiguration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inspect(jobtype, path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobtype: spark job type (required)
        :param str path: path (required)
        :param int project_id: (required)
        :return: SparkJobConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.inspect_with_http_info(jobtype, path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.inspect_with_http_info(jobtype, path, project_id, **kwargs)  # noqa: E501
            return data

    def inspect_with_http_info(self, jobtype, path, project_id, **kwargs):  # noqa: E501
        """Inspect Spark user program and return SparkJobConfiguration  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.inspect_with_http_info(jobtype, path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str jobtype: spark job type (required)
        :param str path: path (required)
        :param int project_id: (required)
        :return: SparkJobConfiguration
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['jobtype', 'path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method inspect" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'jobtype' is set
        if ('jobtype' not in params or
                params['jobtype'] is None):
            raise ValueError("Missing the required parameter `jobtype` when calling `inspect`")  # noqa: E501
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `inspect`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `inspect`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'jobtype' in params:
            path_params['jobtype'] = params['jobtype']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{jobtype}/inspection', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SparkJobConfiguration',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def install(self, library, version2, project_id, **kwargs):  # noqa: E501
        """Install a python library in the environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.install(library, version2, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version2: (required)
        :param int project_id: (required)
        :param str package_manager:
        :param str version:
        :param str channel:
        :param str machine:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.install_with_http_info(library, version2, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.install_with_http_info(library, version2, project_id, **kwargs)  # noqa: E501
            return data

    def install_with_http_info(self, library, version2, project_id, **kwargs):  # noqa: E501
        """Install a python library in the environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.install_with_http_info(library, version2, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version2: (required)
        :param int project_id: (required)
        :param str package_manager:
        :param str version:
        :param str channel:
        :param str machine:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'version2', 'project_id', 'package_manager', 'version', 'channel', 'machine']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method install" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `install`")  # noqa: E501
        # verify the required parameter 'version2' is set
        if ('version2' not in params or
                params['version2'] is None):
            raise ValueError("Missing the required parameter `version2` when calling `install`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `install`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'version2' in params:
            path_params['version'] = params['version2']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'package_manager' in params:
            query_params.append(('package_manager', params['package_manager']))  # noqa: E501
        if 'version' in params:
            query_params.append(('version', params['version']))  # noqa: E501
        if 'channel' in params:
            query_params.append(('channel', params['channel']))  # noqa: E501
        if 'machine' in params:
            query_params.append(('machine', params['machine']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_dir(self, path, project_id, **kwargs):  # noqa: E501
        """is_dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_dir(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.is_dir_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.is_dir_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def is_dir_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """is_dir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_dir_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_dir" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `is_dir`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `is_dir`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/isDir/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_dir1(self, path, project_id, **kwargs):  # noqa: E501
        """is_dir1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_dir1(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.is_dir1_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.is_dir1_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def is_dir1_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """is_dir1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_dir1_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_dir1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `is_dir1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `is_dir1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/localfs/isDir/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def is_running(self, project_id, **kwargs):  # noqa: E501
        """is_running  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_running(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.is_running_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.is_running_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def is_running_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """is_running  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.is_running_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method is_running" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `is_running`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/running', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_schemas_for_topics(self, project_id, **kwargs):  # noqa: E501
        """list_schemas_for_topics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_schemas_for_topics(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_schemas_for_topics_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_schemas_for_topics_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def list_schemas_for_topics_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """list_schemas_for_topics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_schemas_for_topics_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_schemas_for_topics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `list_schemas_for_topics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/schemas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def livy_sessions(self, project_id, **kwargs):  # noqa: E501
        """livy_sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.livy_sessions(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.livy_sessions_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.livy_sessions_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def livy_sessions_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """livy_sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.livy_sessions_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method livy_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `livy_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/livy/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def move_file(self, project_id, **kwargs):  # noqa: E501
        """move_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_file(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param MoveDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.move_file_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.move_file_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def move_file_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """move_file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.move_file_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param MoveDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method move_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `move_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/move', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def new_featurestore_util(self, project_id, **kwargs):  # noqa: E501
        """Upload json input for featurestore-util jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.new_featurestore_util(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param FeaturestoreUtilJobDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.new_featurestore_util_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.new_featurestore_util_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def new_featurestore_util_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Upload json input for featurestore-util jobs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.new_featurestore_util_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param FeaturestoreUtilJobDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method new_featurestore_util" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `new_featurestore_util`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/util', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post(self, version, project_id, **kwargs):  # noqa: E501
        """Create an environment from version or export an environment as yaml file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param str action:
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_with_http_info(version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_with_http_info(version, project_id, **kwargs)  # noqa: E501
            return data

    def post_with_http_info(self, version, project_id, **kwargs):  # noqa: E501
        """Create an environment from version or export an environment as yaml file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_with_http_info(version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str version: (required)
        :param int project_id: (required)
        :param str action:
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['version', 'project_id', 'action']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `post`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `post`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnvironmentDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_yml(self, project_id, **kwargs):  # noqa: E501
        """Create an environment from yaml file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_yml(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param EnvironmentYmlDTO body:
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_yml_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_yml_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def post_yml_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create an environment from yaml file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_yml_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param EnvironmentYmlDTO body:
        :return: EnvironmentDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_yml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `post_yml`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='EnvironmentDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def publish(self, project_id, **kwargs):  # noqa: E501
        """publish  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param InodeIdDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.publish_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.publish_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def publish_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """publish  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.publish_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param InodeIdDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method publish" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `publish`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/uploads', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put(self, name, project_id, **kwargs):  # noqa: E501
        """Create or Update a Job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :param int project_id: (required)
        :param JobConfiguration body:
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_with_http_info(name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_with_http_info(name, project_id, **kwargs)  # noqa: E501
            return data

    def put_with_http_info(self, name, project_id, **kwargs):  # noqa: E501
        """Create or Update a Job.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_with_http_info(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: name (required)
        :param int project_id: (required)
        :param JobConfiguration body:
        :return: JobDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `put`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotas_by_project_id(self, project_id, **kwargs):  # noqa: E501
        """quotas_by_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_by_project_id(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotas_by_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.quotas_by_project_id_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def quotas_by_project_id_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """quotas_by_project_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_by_project_id_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotas_by_project_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `quotas_by_project_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/quotas', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def quotas_by_project_id1(self, project_id, project_name, inode_id, **kwargs):  # noqa: E501
        """quotas_by_project_id1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_by_project_id1(project_id, project_name, inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str project_name: (required)
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.quotas_by_project_id1_with_http_info(project_id, project_name, inode_id, **kwargs)  # noqa: E501
        else:
            (data) = self.quotas_by_project_id1_with_http_info(project_id, project_name, inode_id, **kwargs)  # noqa: E501
            return data

    def quotas_by_project_id1_with_http_info(self, project_id, project_name, inode_id, **kwargs):  # noqa: E501
        """quotas_by_project_id1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.quotas_by_project_id1_with_http_info(project_id, project_name, inode_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param str project_name: (required)
        :param int inode_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'project_name', 'inode_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method quotas_by_project_id1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `quotas_by_project_id1`")  # noqa: E501
        # verify the required parameter 'project_name' is set
        if ('project_name' not in params or
                params['project_name'] is None):
            raise ValueError("Missing the required parameter `project_name` when calling `quotas_by_project_id1`")  # noqa: E501
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `quotas_by_project_id1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501
        if 'project_name' in params:
            path_params['projectName'] = params['project_name']  # noqa: E501
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/importPublicDataset/{projectName}/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reject_request(self, inode_id, project_id, **kwargs):  # noqa: E501
        """reject_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reject_request(inode_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reject_request_with_http_info(inode_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reject_request_with_http_info(inode_id, project_id, **kwargs)  # noqa: E501
            return data

    def reject_request_with_http_info(self, inode_id, project_id, **kwargs):  # noqa: E501
        """reject_request  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reject_request_with_http_info(inode_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inode_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reject_request" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `reject_request`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `reject_request`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/reject/{inodeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_acls_from_topic(self, topic, id, project_id, **kwargs):  # noqa: E501
        """Remove ACL specified by id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_acls_from_topic(topic, id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_acls_from_topic_with_http_info(topic, id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_acls_from_topic_with_http_info(topic, id, project_id, **kwargs)  # noqa: E501
            return data

    def remove_acls_from_topic_with_http_info(self, topic, id, project_id, **kwargs):  # noqa: E501
        """Remove ACL specified by id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_acls_from_topic_with_http_info(topic, id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_acls_from_topic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `remove_acls_from_topic`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `remove_acls_from_topic`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_acls_from_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/acls/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_corrupted(self, file_name, project_id, **kwargs):  # noqa: E501
        """remove_corrupted  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_corrupted(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_corrupted_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_corrupted_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
            return data

    def remove_corrupted_with_http_info(self, file_name, project_id, **kwargs):  # noqa: E501
        """remove_corrupted  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_corrupted_with_http_info(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_corrupted" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `remove_corrupted`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_corrupted`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['fileName'] = params['file_name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/corrupted/{fileName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_members_by_id(self, email, project_id, **kwargs):  # noqa: E501
        """remove_members_by_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_members_by_id(email, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_members_by_id_with_http_info(email, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_members_by_id_with_http_info(email, project_id, **kwargs)  # noqa: E501
            return data

    def remove_members_by_id_with_http_info(self, email, project_id, **kwargs):  # noqa: E501
        """remove_members_by_id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_members_by_id_with_http_info(email, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_members_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `remove_members_by_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_members_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/projectMembers/{email}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_project_and_files(self, project_id, **kwargs):  # noqa: E501
        """remove_project_and_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_project_and_files(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_project_and_files_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_project_and_files_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def remove_project_and_files_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """remove_project_and_files  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_project_and_files_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_project_and_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_project_and_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/delete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_public(self, public_ds_id, clean, project_id, **kwargs):  # noqa: E501
        """remove_public  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_public(public_ds_id, clean, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param bool clean: delete dataset (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_public_with_http_info(public_ds_id, clean, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_public_with_http_info(public_ds_id, clean, project_id, **kwargs)  # noqa: E501
            return data

    def remove_public_with_http_info(self, public_ds_id, clean, project_id, **kwargs):  # noqa: E501
        """remove_public  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_public_with_http_info(public_ds_id, clean, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param bool clean: delete dataset (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_ds_id', 'clean', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_public" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_ds_id' is set
        if ('public_ds_id' not in params or
                params['public_ds_id'] is None):
            raise ValueError("Missing the required parameter `public_ds_id` when calling `remove_public`")  # noqa: E501
        # verify the required parameter 'clean' is set
        if ('clean' not in params or
                params['clean'] is None):
            raise ValueError("Missing the required parameter `clean` when calling `remove_public`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_public`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'public_ds_id' in params:
            path_params['publicDSId'] = params['public_ds_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'clean' in params:
            query_params.append(('clean', params['clean']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/transfers/{publicDSId}/cancel', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_public1(self, inode_id, project_id, **kwargs):  # noqa: E501
        """remove_public1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_public1(inode_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_public1_with_http_info(inode_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_public1_with_http_info(inode_id, project_id, **kwargs)  # noqa: E501
            return data

    def remove_public1_with_http_info(self, inode_id, project_id, **kwargs):  # noqa: E501
        """remove_public1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_public1_with_http_info(inode_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int inode_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['inode_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_public1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'inode_id' is set
        if ('inode_id' not in params or
                params['inode_id'] is None):
            raise ValueError("Missing the required parameter `inode_id` when calling `remove_public1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_public1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'inode_id' in params:
            path_params['inodeId'] = params['inode_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/delacluster/{inodeId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_topic(self, topic, project_id, **kwargs):  # noqa: E501
        """Delete a Kafka topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_topic(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_topic_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_topic_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def remove_topic_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """Delete a Kafka topic.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_topic_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_topic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `remove_topic`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `remove_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def removedata_setdir(self, file_name, project_id, **kwargs):  # noqa: E501
        """removedata_setdir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.removedata_setdir(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.removedata_setdir_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.removedata_setdir_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
            return data

    def removedata_setdir_with_http_info(self, file_name, project_id, **kwargs):  # noqa: E501
        """removedata_setdir  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.removedata_setdir_with_http_info(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method removedata_setdir" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `removedata_setdir`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `removedata_setdir`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['fileName'] = params['file_name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/{fileName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def removedata_setdir1(self, file_name, project_id, **kwargs):  # noqa: E501
        """removedata_setdir1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.removedata_setdir1(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.removedata_setdir1_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.removedata_setdir1_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
            return data

    def removedata_setdir1_with_http_info(self, file_name, project_id, **kwargs):  # noqa: E501
        """removedata_setdir1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.removedata_setdir1_with_http_info(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method removedata_setdir1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `removedata_setdir1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `removedata_setdir1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['fileName'] = params['file_name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/localfs/{fileName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def removefile(self, file_name, project_id, **kwargs):  # noqa: E501
        """removefile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.removefile(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.removefile_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.removefile_with_http_info(file_name, project_id, **kwargs)  # noqa: E501
            return data

    def removefile_with_http_info(self, file_name, project_id, **kwargs):  # noqa: E501
        """removefile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.removefile_with_http_info(file_name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str file_name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['file_name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method removefile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'file_name' is set
        if ('file_name' not in params or
                params['file_name'] is None):
            raise ValueError("Missing the required parameter `file_name` when calling `removefile`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `removefile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'file_name' in params:
            path_params['fileName'] = params['file_name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/file/{fileName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retry_log(self, id, type, name, project_id, **kwargs):  # noqa: E501
        """Retry log aggregation of given execution and type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retry_log(id, type, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str type: (required)
        :param str name: (required)
        :param int project_id: (required)
        :return: JobLogDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retry_log_with_http_info(id, type, name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retry_log_with_http_info(id, type, name, project_id, **kwargs)  # noqa: E501
            return data

    def retry_log_with_http_info(self, id, type, name, project_id, **kwargs):  # noqa: E501
        """Retry log aggregation of given execution and type  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retry_log_with_http_info(id, type, name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int id: (required)
        :param str type: (required)
        :param str name: (required)
        :param int project_id: (required)
        :return: JobLogDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'type', 'name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retry_log" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `retry_log`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `retry_log`")  # noqa: E501
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `retry_log`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `retry_log`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'type' in params:
            path_params['type'] = params['type']  # noqa: E501
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/executions/{id}/log/{type}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobLogDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search(self, search, version, project_id, **kwargs):  # noqa: E501
        """Search for libraries using conda or pip package managers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search(search, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search: (required)
        :param str version: (required)
        :param int project_id: (required)
        :param str query:
        :param str channel:
        :return: LibrarySearchDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_with_http_info(search, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.search_with_http_info(search, version, project_id, **kwargs)  # noqa: E501
            return data

    def search_with_http_info(self, search, version, project_id, **kwargs):  # noqa: E501
        """Search for libraries using conda or pip package managers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_with_http_info(search, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str search: (required)
        :param str version: (required)
        :param int project_id: (required)
        :param str query:
        :param str channel:
        :return: LibrarySearchDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['search', 'version', 'project_id', 'query', 'channel']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'search' is set
        if ('search' not in params or
                params['search'] is None):
            raise ValueError("Missing the required parameter `search` when calling `search`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `search`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `search`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'search' in params:
            path_params['search'] = params['search']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'channel' in params:
            query_params.append(('channel', params['channel']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{search}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LibrarySearchDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def secret_dir(self, project_id, **kwargs):  # noqa: E501
        """Create project secret directory in Airflow home  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.secret_dir(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.secret_dir_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.secret_dir_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def secret_dir_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Create project secret directory in Airflow home  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.secret_dir_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method secret_dir" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `secret_dir`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/airflow/secretDir', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_permissions(self, project_id, **kwargs):  # noqa: E501
        """Set permissions (potentially with sticky bit) for datasets  # noqa: E501

        Allow data scientists to create and modify own files in dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_permissions(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_permissions_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_permissions_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def set_permissions_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Set permissions (potentially with sticky bit) for datasets  # noqa: E501

        Allow data scientists to create and modify own files in dataset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_permissions_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_permissions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `set_permissions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/permissions', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def settings(self, project_id, **kwargs):  # noqa: E501
        """settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.settings(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.settings_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.settings_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def settings_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """settings  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.settings_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def share(self, project_id, **kwargs):  # noqa: E501
        """share  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.share(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param InodeIdDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.share_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.share_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def share_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """share  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.share_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param InodeIdDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method share" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `share`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/delacluster', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def share_data_set(self, project_id, **kwargs):  # noqa: E501
        """share_data_set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.share_data_set(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.share_data_set_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.share_data_set_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def share_data_set_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """share_data_set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.share_data_set_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method share_data_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `share_data_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/shareDataSet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def share_topic(self, topic, dest_project_id, project_id, **kwargs):  # noqa: E501
        """Share a Kafka topic with a project.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.share_topic(topic, dest_project_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int dest_project_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.share_topic_with_http_info(topic, dest_project_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.share_topic_with_http_info(topic, dest_project_id, project_id, **kwargs)  # noqa: E501
            return data

    def share_topic_with_http_info(self, topic, dest_project_id, project_id, **kwargs):  # noqa: E501
        """Share a Kafka topic with a project.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.share_topic_with_http_info(topic, dest_project_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int dest_project_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'dest_project_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method share_topic" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `share_topic`")  # noqa: E501
        # verify the required parameter 'dest_project_id' is set
        if ('dest_project_id' not in params or
                params['dest_project_id'] is None):
            raise ValueError("Missing the required parameter `dest_project_id` when calling `share_topic`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `share_topic`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'dest_project_id' in params:
            path_params['destProjectId'] = params['dest_project_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/shared/{destProjectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_manifest(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """show_manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_manifest(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_manifest_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_manifest_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
            return data

    def show_manifest_with_http_info(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """show_manifest  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_manifest_with_http_info(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_ds_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_manifest" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_ds_id' is set
        if ('public_ds_id' not in params or
                params['public_ds_id'] is None):
            raise ValueError("Missing the required parameter `public_ds_id` when calling `show_manifest`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `show_manifest`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'public_ds_id' in params:
            path_params['publicDSId'] = params['public_ds_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/transfers/{publicDSId}/manifest', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_download(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """start_download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_download(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :param Download body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_download_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_download_with_http_info(public_ds_id, project_id, **kwargs)  # noqa: E501
            return data

    def start_download_with_http_info(self, public_ds_id, project_id, **kwargs):  # noqa: E501
        """start_download  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_download_with_http_info(public_ds_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str public_ds_id: (required)
        :param int project_id: (required)
        :param Download body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['public_ds_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_download" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'public_ds_id' is set
        if ('public_ds_id' not in params or
                params['public_ds_id'] is None):
            raise ValueError("Missing the required parameter `public_ds_id` when calling `start_download`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `start_download`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'public_ds_id' in params:
            path_params['publicDSId'] = params['public_ds_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dela/downloads/{publicDSId}/manifest', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_notebook_server(self, project_id, **kwargs):  # noqa: E501
        """start_notebook_server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_notebook_server(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param JupyterSettings body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_notebook_server_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_notebook_server_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def start_notebook_server_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """start_notebook_server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_notebook_server_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param JupyterSettings body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_notebook_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `start_notebook_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/start', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_or_stop(self, serving_id, action, project_id, **kwargs):  # noqa: E501
        """Start or stop a Serving instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_or_stop(serving_id, action, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int serving_id: ID of the Serving instance to start/stop (required)
        :param str action: Action (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_or_stop_with_http_info(serving_id, action, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_or_stop_with_http_info(serving_id, action, project_id, **kwargs)  # noqa: E501
            return data

    def start_or_stop_with_http_info(self, serving_id, action, project_id, **kwargs):  # noqa: E501
        """Start or stop a Serving instance  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_or_stop_with_http_info(serving_id, action, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int serving_id: ID of the Serving instance to start/stop (required)
        :param str action: Action (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['serving_id', 'action', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_or_stop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'serving_id' is set
        if ('serving_id' not in params or
                params['serving_id'] is None):
            raise ValueError("Missing the required parameter `serving_id` when calling `start_or_stop`")  # noqa: E501
        # verify the required parameter 'action' is set
        if ('action' not in params or
                params['action'] is None):
            raise ValueError("Missing the required parameter `action` when calling `start_or_stop`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `start_or_stop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'serving_id' in params:
            path_params['servingId'] = params['serving_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'action' in params:
            query_params.append(('action', params['action']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/serving/{servingId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def start_tensor_board(self, elastic_id, project_id, **kwargs):  # noqa: E501
        """Start a new TensorBoard for the logged in user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_tensor_board(elastic_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str elastic_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.start_tensor_board_with_http_info(elastic_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.start_tensor_board_with_http_info(elastic_id, project_id, **kwargs)  # noqa: E501
            return data

    def start_tensor_board_with_http_info(self, elastic_id, project_id, **kwargs):  # noqa: E501
        """Start a new TensorBoard for the logged in user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.start_tensor_board_with_http_info(elastic_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str elastic_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['elastic_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_tensor_board" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'elastic_id' is set
        if ('elastic_id' not in params or
                params['elastic_id'] is None):
            raise ValueError("Missing the required parameter `elastic_id` when calling `start_tensor_board`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `start_tensor_board`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'elastic_id' in params:
            path_params['elasticId'] = params['elastic_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/tensorboard/{elasticId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_livy_session(self, app_id, project_id, **kwargs):  # noqa: E501
        """stop_livy_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_livy_session(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_livy_session_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.stop_livy_session_with_http_info(app_id, project_id, **kwargs)  # noqa: E501
            return data

    def stop_livy_session_with_http_info(self, app_id, project_id, **kwargs):  # noqa: E501
        """stop_livy_session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_livy_session_with_http_info(app_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str app_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['app_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_livy_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'app_id' is set
        if ('app_id' not in params or
                params['app_id'] is None):
            raise ValueError("Missing the required parameter `app_id` when calling `stop_livy_session`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `stop_livy_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'app_id' in params:
            path_params['appId'] = params['app_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/livy/sessions/{appId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_notebook_server(self, project_id, **kwargs):  # noqa: E501
        """stop_notebook_server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_notebook_server(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_notebook_server_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.stop_notebook_server_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def stop_notebook_server_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """stop_notebook_server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_notebook_server_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_notebook_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `stop_notebook_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/stop', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def stop_tensor_board(self, project_id, **kwargs):  # noqa: E501
        """Stop the running TensorBoard for the logged in user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_tensor_board(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.stop_tensor_board_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.stop_tensor_board_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def stop_tensor_board_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Stop the running TensorBoard for the logged in user  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.stop_tensor_board_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_tensor_board" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `stop_tensor_board`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/tensorboard', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def store_airflow_jwt(self, project_id, **kwargs):  # noqa: E501
        """Generate a JWT for Airflow usage and store it in project's secret directory in Airflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_airflow_jwt(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.store_airflow_jwt_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.store_airflow_jwt_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def store_airflow_jwt_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """Generate a JWT for Airflow usage and store it in project's secret directory in Airflow  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.store_airflow_jwt_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method store_airflow_jwt" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `store_airflow_jwt`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/airflow/jwt', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def sync_with_featurestore(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Synchornize Hive Table with the feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sync_with_featurestore(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturegroupDTO body:
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.sync_with_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.sync_with_featurestore_with_http_info(featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def sync_with_featurestore_with_http_info(self, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Synchornize Hive Table with the feature store  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.sync_with_featurestore_with_http_info(featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturegroupDTO body:
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featurestore_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method sync_with_featurestore" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `sync_with_featurestore`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `sync_with_featurestore`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/sync', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturegroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def test_method1(self, path, project_id, **kwargs):  # noqa: E501
        """test_method1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_method1(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param int template_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.test_method1_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.test_method1_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def test_method1_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """test_method1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.test_method1_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param int template_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id', 'template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method test_method1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `test_method1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `test_method1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'template_id' in params:
            query_params.append(('templateId', params['template_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/upload/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def topic_is_shared_to(self, topic, project_id, **kwargs):  # noqa: E501
        """Get list of projects that a topic has been shared with.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.topic_is_shared_to(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.topic_is_shared_to_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.topic_is_shared_to_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def topic_is_shared_to_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """Get list of projects that a topic has been shared with.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.topic_is_shared_to_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method topic_is_shared_to" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `topic_is_shared_to`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `topic_is_shared_to`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/shared', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def uninstall(self, library, version, project_id, **kwargs):  # noqa: E501
        """Uninstall a python library from the environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uninstall(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.uninstall_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.uninstall_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
            return data

    def uninstall_with_http_info(self, library, version, project_id, **kwargs):  # noqa: E501
        """Uninstall a python library from the environment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.uninstall_with_http_info(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method uninstall" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `uninstall`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `uninstall`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `uninstall`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unschedule_job(self, name, project_id, **kwargs):  # noqa: E501
        """Cancel a job's schedule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unschedule_job(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unschedule_job_with_http_info(name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unschedule_job_with_http_info(name, project_id, **kwargs)  # noqa: E501
            return data

    def unschedule_job_with_http_info(self, name, project_id, **kwargs):  # noqa: E501
        """Cancel a job's schedule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unschedule_job_with_http_info(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unschedule_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `unschedule_job`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `unschedule_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/schedule', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unshare_data_set(self, project_id, **kwargs):  # noqa: E501
        """unshare_data_set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unshare_data_set(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unshare_data_set_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unshare_data_set_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def unshare_data_set_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """unshare_data_set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unshare_data_set_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param DataSetDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unshare_data_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `unshare_data_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/unshareDataSet', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unshare_topic_from_project(self, topic, dest_project_id, project_id, **kwargs):  # noqa: E501
        """Unshare Kafka topic from a project (specified as destProjectId).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unshare_topic_from_project(topic, dest_project_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int dest_project_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unshare_topic_from_project_with_http_info(topic, dest_project_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unshare_topic_from_project_with_http_info(topic, dest_project_id, project_id, **kwargs)  # noqa: E501
            return data

    def unshare_topic_from_project_with_http_info(self, topic, dest_project_id, project_id, **kwargs):  # noqa: E501
        """Unshare Kafka topic from a project (specified as destProjectId).  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unshare_topic_from_project_with_http_info(topic, dest_project_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int dest_project_id: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'dest_project_id', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unshare_topic_from_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `unshare_topic_from_project`")  # noqa: E501
        # verify the required parameter 'dest_project_id' is set
        if ('dest_project_id' not in params or
                params['dest_project_id'] is None):
            raise ValueError("Missing the required parameter `dest_project_id` when calling `unshare_topic_from_project`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `unshare_topic_from_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'dest_project_id' in params:
            path_params['destProjectId'] = params['dest_project_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/shared/{destProjectId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unshare_topic_from_projects(self, topic, project_id, **kwargs):  # noqa: E501
        """Unshare Kafka topic from all projects.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unshare_topic_from_projects(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unshare_topic_from_projects_with_http_info(topic, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unshare_topic_from_projects_with_http_info(topic, project_id, **kwargs)  # noqa: E501
            return data

    def unshare_topic_from_projects_with_http_info(self, topic, project_id, **kwargs):  # noqa: E501
        """Unshare Kafka topic from all projects.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unshare_topic_from_projects_with_http_info(topic, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unshare_topic_from_projects" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `unshare_topic_from_projects`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `unshare_topic_from_projects`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/shared', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unzip(self, path, project_id, **kwargs):  # noqa: E501
        """unzip  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unzip(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unzip_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unzip_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def unzip_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """unzip  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unzip_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unzip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `unzip`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `unzip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/unzip/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update(self, library, version, project_id, **kwargs):  # noqa: E501
        """Update commands for this library  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_with_http_info(library, version, project_id, **kwargs)  # noqa: E501
            return data

    def update_with_http_info(self, library, version, project_id, **kwargs):  # noqa: E501
        """Update commands for this library  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_with_http_info(library, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str library: (required)
        :param str version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['library', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'library' is set
        if ('library' not in params or
                params['library'] is None):
            raise ValueError("Missing the required parameter `library` when calling `update`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `update`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'library' in params:
            path_params['library'] = params['library']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/python/environments/{version}/libraries/{library}/commands', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_featuregroup(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Update featuregroup contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_featuregroup(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturegroupDTO body:
        :param bool update_metadata: updateMetadata
        :param bool update_stats: updateStats
        :param bool enable_online: enableOnline
        :param bool disable_online: disableOnline
        :param bool update_stats_settings: updateStatsSettings
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_featuregroup_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_featuregroup_with_http_info(featuregroup_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def update_featuregroup_with_http_info(self, featuregroup_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Update featuregroup contents  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_featuregroup_with_http_info(featuregroup_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int featuregroup_id: Id of the featuregroup (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturegroupDTO body:
        :param bool update_metadata: updateMetadata
        :param bool update_stats: updateStats
        :param bool enable_online: enableOnline
        :param bool disable_online: disableOnline
        :param bool update_stats_settings: updateStatsSettings
        :return: FeaturegroupDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['featuregroup_id', 'featurestore_id', 'project_id', 'body', 'update_metadata', 'update_stats', 'enable_online', 'disable_online', 'update_stats_settings']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_featuregroup" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'featuregroup_id' is set
        if ('featuregroup_id' not in params or
                params['featuregroup_id'] is None):
            raise ValueError("Missing the required parameter `featuregroup_id` when calling `update_featuregroup`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `update_featuregroup`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_featuregroup`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'featuregroup_id' in params:
            path_params['featuregroupId'] = params['featuregroup_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'update_metadata' in params:
            query_params.append(('updateMetadata', params['update_metadata']))  # noqa: E501
        if 'update_stats' in params:
            query_params.append(('updateStats', params['update_stats']))  # noqa: E501
        if 'enable_online' in params:
            query_params.append(('enableOnline', params['enable_online']))  # noqa: E501
        if 'disable_online' in params:
            query_params.append(('disableOnline', params['disable_online']))  # noqa: E501
        if 'update_stats_settings' in params:
            query_params.append(('updateStatsSettings', params['update_stats_settings']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/featuregroups/{featuregroupId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturegroupDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_notebook_server(self, project_id, **kwargs):  # noqa: E501
        """update_notebook_server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_notebook_server(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param JupyterSettings body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_notebook_server_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_notebook_server_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def update_notebook_server_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """update_notebook_server  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_notebook_server_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param JupyterSettings body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_notebook_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_notebook_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jupyter/update', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_pia(self, project_id, **kwargs):  # noqa: E501
        """update_pia  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_pia(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param Pia body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_pia_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_pia_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def update_pia_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """update_pia  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_pia_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param Pia body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_pia" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_pia`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/pia', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_project(self, project_id, **kwargs):  # noqa: E501
        """update_project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param ProjectDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_project_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_project_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def update_project_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """update_project  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_project_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param ProjectDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_project" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_project`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_role_by_email(self, email, project_id, **kwargs):  # noqa: E501
        """update_role_by_email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_by_email(email, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: (required)
        :param int project_id: (required)
        :param str role:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_role_by_email_with_http_info(email, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_role_by_email_with_http_info(email, project_id, **kwargs)  # noqa: E501
            return data

    def update_role_by_email_with_http_info(self, email, project_id, **kwargs):  # noqa: E501
        """update_role_by_email  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_role_by_email_with_http_info(email, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str email: (required)
        :param int project_id: (required)
        :param str role:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['email', 'project_id', 'role']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_role_by_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'email' is set
        if ('email' not in params or
                params['email'] is None):
            raise ValueError("Missing the required parameter `email` when calling `update_role_by_email`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_role_by_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'email' in params:
            path_params['email'] = params['email']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'role' in params:
            form_params.append(('role', params['role']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/projectMembers/{email}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_schedule(self, name, project_id, **kwargs):  # noqa: E501
        """Create/Update job's schedule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_schedule(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :param ScheduleDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_schedule_with_http_info(name, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_schedule_with_http_info(name, project_id, **kwargs)  # noqa: E501
            return data

    def update_schedule_with_http_info(self, name, project_id, **kwargs):  # noqa: E501
        """Create/Update job's schedule.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_schedule_with_http_info(name, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: (required)
        :param int project_id: (required)
        :param ScheduleDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_schedule" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `update_schedule`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_schedule`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/jobs/{name}/schedule', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_schema_version(self, topic, version, project_id, **kwargs):  # noqa: E501
        """update_schema_version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_schema_version(topic, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_schema_version_with_http_info(topic, version, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_schema_version_with_http_info(topic, version, project_id, **kwargs)  # noqa: E501
            return data

    def update_schema_version_with_http_info(self, topic, version, project_id, **kwargs):  # noqa: E501
        """update_schema_version  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_schema_version_with_http_info(topic, version, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int version: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'version', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_schema_version" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `update_schema_version`")  # noqa: E501
        # verify the required parameter 'version' is set
        if ('version' not in params or
                params['version'] is None):
            raise ValueError("Missing the required parameter `version` when calling `update_schema_version`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_schema_version`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'version' in params:
            path_params['version'] = params['version']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/{topic}/schema/version/{version}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_storage_connector_with_id(self, connector_type, connector_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get a storage connector with a specific id and type from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_storage_connector_with_id(connector_type, connector_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int connector_id: Id of the storage connector (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturestoreStorageConnectorDTO body:
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_storage_connector_with_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_storage_connector_with_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def update_storage_connector_with_id_with_http_info(self, connector_type, connector_id, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Get a storage connector with a specific id and type from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_storage_connector_with_id_with_http_info(connector_type, connector_id, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str connector_type: storage connector type (required)
        :param int connector_id: Id of the storage connector (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param FeaturestoreStorageConnectorDTO body:
        :return: FeaturestoreStorageConnectorDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['connector_type', 'connector_id', 'featurestore_id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_storage_connector_with_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'connector_type' is set
        if ('connector_type' not in params or
                params['connector_type'] is None):
            raise ValueError("Missing the required parameter `connector_type` when calling `update_storage_connector_with_id`")  # noqa: E501
        # verify the required parameter 'connector_id' is set
        if ('connector_id' not in params or
                params['connector_id'] is None):
            raise ValueError("Missing the required parameter `connector_id` when calling `update_storage_connector_with_id`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `update_storage_connector_with_id`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_storage_connector_with_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'connector_type' in params:
            path_params['connectorType'] = params['connector_type']  # noqa: E501
        if 'connector_id' in params:
            path_params['connectorId'] = params['connector_id']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/storageconnectors/{connectorType}/{connectorId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FeaturestoreStorageConnectorDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_topic_acls(self, topic, id, project_id, **kwargs):  # noqa: E501
        """Update ACL specified by id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topic_acls(topic, id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int id: (required)
        :param int project_id: (required)
        :param AclDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_topic_acls_with_http_info(topic, id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_topic_acls_with_http_info(topic, id, project_id, **kwargs)  # noqa: E501
            return data

    def update_topic_acls_with_http_info(self, topic, id, project_id, **kwargs):  # noqa: E501
        """Update ACL specified by id.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_topic_acls_with_http_info(topic, id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str topic: (required)
        :param int id: (required)
        :param int project_id: (required)
        :param AclDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['topic', 'id', 'project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_topic_acls" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'topic' is set
        if ('topic' not in params or
                params['topic'] is None):
            raise ValueError("Missing the required parameter `topic` when calling `update_topic_acls`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `update_topic_acls`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_topic_acls`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'topic' in params:
            path_params['topic'] = params['topic']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/topics/{topic}/acls/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_training_dataset(self, trainingdatasetid, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Update a training datasets with a specific id from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_training_dataset(trainingdatasetid, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trainingdatasetid: Id of the training dataset (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param TrainingDatasetDTO body:
        :param bool update_metadata: updateMetadata
        :param bool update_stats: updateStats
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_training_dataset_with_http_info(trainingdatasetid, featurestore_id, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_training_dataset_with_http_info(trainingdatasetid, featurestore_id, project_id, **kwargs)  # noqa: E501
            return data

    def update_training_dataset_with_http_info(self, trainingdatasetid, featurestore_id, project_id, **kwargs):  # noqa: E501
        """Update a training datasets with a specific id from a featurestore  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_training_dataset_with_http_info(trainingdatasetid, featurestore_id, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int trainingdatasetid: Id of the training dataset (required)
        :param int featurestore_id: (required)
        :param int project_id: (required)
        :param TrainingDatasetDTO body:
        :param bool update_metadata: updateMetadata
        :param bool update_stats: updateStats
        :return: TrainingDatasetDTO
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['trainingdatasetid', 'featurestore_id', 'project_id', 'body', 'update_metadata', 'update_stats']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_training_dataset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'trainingdatasetid' is set
        if ('trainingdatasetid' not in params or
                params['trainingdatasetid'] is None):
            raise ValueError("Missing the required parameter `trainingdatasetid` when calling `update_training_dataset`")  # noqa: E501
        # verify the required parameter 'featurestore_id' is set
        if ('featurestore_id' not in params or
                params['featurestore_id'] is None):
            raise ValueError("Missing the required parameter `featurestore_id` when calling `update_training_dataset`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `update_training_dataset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'trainingdatasetid' in params:
            path_params['trainingdatasetid'] = params['trainingdatasetid']  # noqa: E501
        if 'featurestore_id' in params:
            path_params['featurestoreId'] = params['featurestore_id']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'update_metadata' in params:
            query_params.append(('updateMetadata', params['update_metadata']))  # noqa: E501
        if 'update_stats' in params:
            query_params.append(('updateStats', params['update_stats']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/featurestores/{featurestoreId}/trainingdatasets/{trainingdatasetid}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TrainingDatasetDTO',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_method1(self, path, project_id, **kwargs):  # noqa: E501
        """upload_method1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_method1(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param file file:
        :param str flow_chunk_number:
        :param str flow_chunk_size:
        :param str flow_current_chunk_size:
        :param str flow_filename:
        :param str flow_identifier:
        :param str flow_relative_path:
        :param str flow_total_chunks:
        :param str flow_total_size:
        :param int template_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_method1_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_method1_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def upload_method1_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """upload_method1  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_method1_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :param file file:
        :param str flow_chunk_number:
        :param str flow_chunk_size:
        :param str flow_current_chunk_size:
        :param str flow_filename:
        :param str flow_identifier:
        :param str flow_relative_path:
        :param str flow_total_chunks:
        :param str flow_total_size:
        :param int template_id:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id', 'file', 'flow_chunk_number', 'flow_chunk_size', 'flow_current_chunk_size', 'flow_filename', 'flow_identifier', 'flow_relative_path', 'flow_total_chunks', 'flow_total_size', 'template_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_method1" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `upload_method1`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `upload_method1`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []
        if 'template_id' in params:
            query_params.append(('templateId', params['template_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}
        if 'file' in params:
            local_var_files['file'] = params['file']  # noqa: E501
        if 'flow_chunk_number' in params:
            form_params.append(('flowChunkNumber', params['flow_chunk_number']))  # noqa: E501
        if 'flow_chunk_size' in params:
            form_params.append(('flowChunkSize', params['flow_chunk_size']))  # noqa: E501
        if 'flow_current_chunk_size' in params:
            form_params.append(('flowCurrentChunkSize', params['flow_current_chunk_size']))  # noqa: E501
        if 'flow_filename' in params:
            form_params.append(('flowFilename', params['flow_filename']))  # noqa: E501
        if 'flow_identifier' in params:
            form_params.append(('flowIdentifier', params['flow_identifier']))  # noqa: E501
        if 'flow_relative_path' in params:
            form_params.append(('flowRelativePath', params['flow_relative_path']))  # noqa: E501
        if 'flow_total_chunks' in params:
            form_params.append(('flowTotalChunks', params['flow_total_chunks']))  # noqa: E501
        if 'flow_total_size' in params:
            form_params.append(('flowTotalSize', params['flow_total_size']))  # noqa: E501

        body_params = None
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['multipart/form-data'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/upload/{path}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def validate_schema_for_topics(self, project_id, **kwargs):  # noqa: E501
        """validate_schema_for_topics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_schema_for_topics(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param SchemaDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.validate_schema_for_topics_with_http_info(project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.validate_schema_for_topics_with_http_info(project_id, **kwargs)  # noqa: E501
            return data

    def validate_schema_for_topics_with_http_info(self, project_id, **kwargs):  # noqa: E501
        """validate_schema_for_topics  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.validate_schema_for_topics_with_http_info(project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int project_id: (required)
        :param SchemaDTO body:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['project_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method validate_schema_for_topics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `validate_schema_for_topics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['*/*'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/kafka/schema/validate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def zip(self, path, project_id, **kwargs):  # noqa: E501
        """zip  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zip(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.zip_with_http_info(path, project_id, **kwargs)  # noqa: E501
        else:
            (data) = self.zip_with_http_info(path, project_id, **kwargs)  # noqa: E501
            return data

    def zip_with_http_info(self, path, project_id, **kwargs):  # noqa: E501
        """zip  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.zip_with_http_info(path, project_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str path: (required)
        :param int project_id: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['path', 'project_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method zip" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'path' is set
        if ('path' not in params or
                params['path'] is None):
            raise ValueError("Missing the required parameter `path` when calling `zip`")  # noqa: E501
        # verify the required parameter 'project_id' is set
        if ('project_id' not in params or
                params['project_id'] is None):
            raise ValueError("Missing the required parameter `project_id` when calling `zip`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'path' in params:
            path_params['path'] = params['path']  # noqa: E501
        if 'project_id' in params:
            path_params['projectId'] = params['project_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/project/{projectId}/dataset/zip/{path}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
