/**
 * Hopsworks api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { AclDTO } from '../model/aclDTO';
import { AclsBeanParam } from '../model/aclsBeanParam';
import { ActivitiesDTO } from '../model/activitiesDTO';
import { AirflowDagDTO } from '../model/airflowDagDTO';
import { CommandDTO } from '../model/commandDTO';
import { ConstraintGroupDTO } from '../model/constraintGroupDTO';
import { DataSetDTO } from '../model/dataSetDTO';
import { DataValidationSettingsDTO } from '../model/dataValidationSettingsDTO';
import { Download } from '../model/download';
import { EnvironmentDTO } from '../model/environmentDTO';
import { EnvironmentYmlDTO } from '../model/environmentYmlDTO';
import { ExecutionDTO } from '../model/executionDTO';
import { FeaturegroupDTO } from '../model/featuregroupDTO';
import { FeaturegroupImportJobDTO } from '../model/featuregroupImportJobDTO';
import { FeaturegroupPreview } from '../model/featuregroupPreview';
import { FeaturestoreClientSettingsDTO } from '../model/featurestoreClientSettingsDTO';
import { FeaturestoreDTO } from '../model/featurestoreDTO';
import { FeaturestoreStorageConnectorDTO } from '../model/featurestoreStorageConnectorDTO';
import { FeaturestoreUtilJobDTO } from '../model/featurestoreUtilJobDTO';
import { FileTemplateDTO } from '../model/fileTemplateDTO';
import { InodeIdDTO } from '../model/inodeIdDTO';
import { JobConfiguration } from '../model/jobConfiguration';
import { JobDTO } from '../model/jobDTO';
import { JobLogDTO } from '../model/jobLogDTO';
import { JupyterSettings } from '../model/jupyterSettings';
import { LibraryDTO } from '../model/libraryDTO';
import { LibrarySearchDTO } from '../model/librarySearchDTO';
import { MembersDTO } from '../model/membersDTO';
import { MoveDTO } from '../model/moveDTO';
import { Pia } from '../model/pia';
import { ProjectDTO } from '../model/projectDTO';
import { RepresentsAServingModel } from '../model/representsAServingModel';
import { RowValueQueryResult } from '../model/rowValueQueryResult';
import { ScheduleDTO } from '../model/scheduleDTO';
import { SchemaDTO } from '../model/schemaDTO';
import { SparkJobConfiguration } from '../model/sparkJobConfiguration';
import { TopicDTO } from '../model/topicDTO';
import { TopicsBeanParam } from '../model/topicsBeanParam';
import { TrainingDatasetDTO } from '../model/trainingDatasetDTO';
import { TrainingDatasetJobDTO } from '../model/trainingDatasetJobDTO';
import { ValidationResult } from '../model/validationResult';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ProjectServiceService {

    protected basePath = '///hopsworks-api/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Delete commands for this environment
     * 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public _delete(version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public _delete(version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public _delete(version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public _delete(version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling _delete.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling _delete.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/commands`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param inodeId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public acceptRequest(inodeId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public acceptRequest(inodeId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public acceptRequest(inodeId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public acceptRequest(inodeId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling acceptRequest.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling acceptRequest.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/accept/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add a new ACL for a specified topic.
     * 
     * @param topic 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addAclsToTopic(topic: string, projectId: number, body?: AclDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addAclsToTopic(topic: string, projectId: number, body?: AclDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addAclsToTopic(topic: string, projectId: number, body?: AclDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addAclsToTopic(topic: string, projectId: number, body?: AclDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling addAclsToTopic.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling addAclsToTopic.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/acls`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addMembers(projectId: number, body?: MembersDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addMembers(projectId: number, body?: MembersDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addMembers(projectId: number, body?: MembersDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addMembers(projectId: number, body?: MembersDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling addMembers.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/projectMembers`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addTopicSchema(projectId: number, body?: SchemaDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public addTopicSchema(projectId: number, body?: SchemaDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public addTopicSchema(projectId: number, body?: SchemaDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public addTopicSchema(projectId: number, body?: SchemaDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling addTopicSchema.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/schema/add`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Write Deequ validation rules to Filesystem so validation job can pick it up
     * 
     * @param featuregroupId 
     * @param featureStoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe?: 'body', reportProgress?: boolean): Observable<DataValidationSettingsDTO>;
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DataValidationSettingsDTO>>;
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DataValidationSettingsDTO>>;
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling addValidationRules.');
        }

        if (featureStoreId === null || featureStoreId === undefined) {
            throw new Error('Required parameter featureStoreId was null or undefined when calling addValidationRules.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling addValidationRules.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DataValidationSettingsDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featureStoreId))}/datavalidation/${encodeURIComponent(String(featuregroupId))}/rules`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public attachTemplate(projectId: number, body?: FileTemplateDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public attachTemplate(projectId: number, body?: FileTemplateDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public attachTemplate(projectId: number, body?: FileTemplateDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public attachTemplate(projectId: number, body?: FileTemplateDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling attachTemplate.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/attachTemplate`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkFileExist(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public checkFileExist(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public checkFileExist(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public checkFileExist(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling checkFileExist.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling checkFileExist.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/localfs/fileExists/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkFileExists(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public checkFileExists(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public checkFileExists(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public checkFileExists(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling checkFileExists.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling checkFileExists.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/fileExists/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkFileForDownload(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public checkFileForDownload(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public checkFileForDownload(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public checkFileForDownload(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling checkFileForDownload.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling checkFileForDownload.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/checkFileForDownload/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public checkProjectAccess(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public checkProjectAccess(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public checkProjectAccess(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public checkProjectAccess(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling checkProjectAccess.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/check`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate an Airflow Python DAG file from a DAG definition
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public composeDAG(projectId: number, body?: AirflowDagDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public composeDAG(projectId: number, body?: AirflowDagDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public composeDAG(projectId: number, body?: AirflowDagDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public composeDAG(projectId: number, body?: AirflowDagDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling composeDAG.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/airflow/dag`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public convertIPythonNotebook(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public convertIPythonNotebook(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public convertIPythonNotebook(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public convertIPythonNotebook(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling convertIPythonNotebook.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling convertIPythonNotebook.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/convertIPythonNotebook/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public copyFile(projectId: number, body?: MoveDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public copyFile(projectId: number, body?: MoveDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public copyFile(projectId: number, body?: MoveDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public copyFile(projectId: number, body?: MoveDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling copyFile.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/copy`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public countFileBlocks(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public countFileBlocks(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public countFileBlocks(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public countFileBlocks(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling countFileBlocks.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling countFileBlocks.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/countFileBlocks/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDataSetDir(projectId: number, body?: DataSetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createDataSetDir(projectId: number, body?: DataSetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createDataSetDir(projectId: number, body?: DataSetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createDataSetDir(projectId: number, body?: DataSetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createDataSetDir.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createDataSetDir1(projectId: number, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createDataSetDir1(projectId: number, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createDataSetDir1(projectId: number, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createDataSetDir1(projectId: number, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createDataSetDir1.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/localfs`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create feature group in a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createFeaturegroup.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createFeaturegroup.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new storage connector for the feature store
     * 
     * @param connectorType storage connector type
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling createNewStorageConnectorWithType.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createNewStorageConnectorWithType.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createNewStorageConnectorWithType.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create or update a serving instance
     * 
     * @param body serving specification
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdate(body: RepresentsAServingModel, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createOrUpdate(body: RepresentsAServingModel, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createOrUpdate(body: RepresentsAServingModel, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createOrUpdate(body: RepresentsAServingModel, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdate.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createOrUpdate.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/serving`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Configure job to import featuregroup
     * 
     * @param body Job configuration
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdateImportJob.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createOrUpdateImportJob.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/importjob`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Configure job to create training dataset
     * 
     * @param body Job configuration
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdateTrainingDatasetJob.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createOrUpdateTrainingDatasetJob.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/trainingdatasetjob`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createProject(body?: ProjectDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createProject(body?: ProjectDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createProject(body?: ProjectDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createProject(body?: ProjectDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTopLevelDataSet(projectId: number, body?: DataSetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createTopLevelDataSet(projectId: number, body?: DataSetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createTopLevelDataSet(projectId: number, body?: DataSetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createTopLevelDataSet(projectId: number, body?: DataSetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createTopLevelDataSet.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/createTopLevelDataSet`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new Kafka topic.
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTopic(projectId: number, body?: TopicDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public createTopic(projectId: number, body?: TopicDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public createTopic(projectId: number, body?: TopicDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public createTopic(projectId: number, body?: TopicDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createTopic.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create training dataset for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createTrainingDataset.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createTrainingDataset.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public credentials(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public credentials(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public credentials(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public credentials(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling credentials.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/credentials`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete commands for this library
     * 
     * @param library 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public delete1(library: string, version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public delete1(library: string, version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public delete1(library: string, version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public delete1(library: string, version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling delete1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling delete1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling delete1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}/commands`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove the python environment with the specified version for this project
     * 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public delete2(version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<EnvironmentDTO>;
    public delete2(version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EnvironmentDTO>>;
    public delete2(version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EnvironmentDTO>>;
    public delete2(version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling delete2.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling delete2.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<EnvironmentDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete the job with the given ID
     * 
     * @param name id
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public delete3(name: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public delete3(name: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public delete3(name: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public delete3(name: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling delete3.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling delete3.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete specific featuregroup from a specific featurestore
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete featuregroup contents
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling deleteFeaturegroupContents.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteFeaturegroupContents.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteFeaturegroupContents.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/clear`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param schemaName 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteSchema(schemaName: string, version: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteSchema(schemaName: string, version: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteSchema(schemaName: string, version: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteSchema(schemaName: string, version: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (schemaName === null || schemaName === undefined) {
            throw new Error('Required parameter schemaName was null or undefined when calling deleteSchema.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteSchema.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteSchema.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/removeSchema/${encodeURIComponent(String(schemaName))}/${encodeURIComponent(String(version))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a serving instance
     * 
     * @param servingId Id of the serving instance
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteServing(servingId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public deleteServing(servingId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public deleteServing(servingId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public deleteServing(servingId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (servingId === null || servingId === undefined) {
            throw new Error('Required parameter servingId was null or undefined when calling deleteServing.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteServing.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/serving/${encodeURIComponent(String(servingId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete storage connector with a specific id and type from a featurestore
     * 
     * @param connectorType storage connector type
     * @param connectorId Id of the storage connector
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}/${encodeURIComponent(String(connectorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a training datasets with a specific id from a featurestore
     * 
     * @param trainingdatasetid Id of the training dataset
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (trainingdatasetid === null || trainingdatasetid === undefined) {
            throw new Error('Required parameter trainingdatasetid was null or undefined when calling deleteTrainingDataset.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteTrainingDataset.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteTrainingDataset.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets/${encodeURIComponent(String(trainingdatasetid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param password 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadCerts(projectId: number, password?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadCerts(projectId: number, password?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadCerts(projectId: number, password?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadCerts(projectId: number, password?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling downloadCerts.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (password !== undefined) {
            formParams = formParams.append('password', <any>password) || formParams;
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/downloadCert`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param publicDSId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadDatasetHdfs(publicDSId: string, projectId: number, body?: Download, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadDatasetHdfs(publicDSId: string, projectId: number, body?: Download, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadDatasetHdfs(publicDSId: string, projectId: number, body?: Download, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadDatasetHdfs(publicDSId: string, projectId: number, body?: Download, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (publicDSId === null || publicDSId === undefined) {
            throw new Error('Required parameter publicDSId was null or undefined when calling downloadDatasetHdfs.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling downloadDatasetHdfs.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/downloads/${encodeURIComponent(String(publicDSId))}/hdfs`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param publicDSId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadDatasetKafka(publicDSId: string, projectId: number, body?: Download, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadDatasetKafka(publicDSId: string, projectId: number, body?: Download, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadDatasetKafka(publicDSId: string, projectId: number, body?: Download, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadDatasetKafka(publicDSId: string, projectId: number, body?: Download, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (publicDSId === null || publicDSId === undefined) {
            throw new Error('Required parameter publicDSId was null or undefined when calling downloadDatasetKafka.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling downloadDatasetKafka.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/downloads/${encodeURIComponent(String(publicDSId))}/kafka`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param token 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public downloadFromHDFS(path: string, projectId: number, token?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public downloadFromHDFS(path: string, projectId: number, token?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public downloadFromHDFS(path: string, projectId: number, token?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public downloadFromHDFS(path: string, projectId: number, token?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling downloadFromHDFS.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling downloadFromHDFS.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (token !== undefined && token !== null) {
            queryParameters = queryParameters.set('token', <any>token);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/fileDownload/${encodeURIComponent(String(path))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param type 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public example(type: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public example(type: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public example(type: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public example(type: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling example.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/starterProject/${encodeURIComponent(String(type))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start/Stop a job
     * Starts a job by creating and starting an Execution, stops a job by stopping the Execution.
     * @param action start or stop
     * @param name 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public execution(action: string, name: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public execution(action: string, name: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public execution(action: string, name: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public execution(action: string, name: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling execution.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling execution.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling execution.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (action !== undefined && action !== null) {
            queryParameters = queryParameters.set('action', <any>action);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/executions`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param mode 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public filePreview(path: string, projectId: number, mode?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public filePreview(path: string, projectId: number, mode?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public filePreview(path: string, projectId: number, mode?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public filePreview(path: string, projectId: number, mode?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling filePreview.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling filePreview.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (mode !== undefined && mode !== null) {
            queryParameters = queryParameters.set('mode', <any>mode);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/filePreview/${encodeURIComponent(String(path))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finds an activity in project.
     * 
     * @param activityId 
     * @param projectId 
     * @param expand ex. expand&#x3D;creator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAllById(activityId: number, projectId: number, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<ActivitiesDTO>;
    public findAllById(activityId: number, projectId: number, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ActivitiesDTO>>;
    public findAllById(activityId: number, projectId: number, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ActivitiesDTO>>;
    public findAllById(activityId: number, projectId: number, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (activityId === null || activityId === undefined) {
            throw new Error('Required parameter activityId was null or undefined when calling findAllById.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findAllById.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ActivitiesDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/activities/${encodeURIComponent(String(activityId))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Finds activities in project.
     * 
     * @param projectId 
     * @param offset 
     * @param limit 
     * @param sortBy ex. sort_by&#x3D;ID:asc,date_created:desc
     * @param filterBy ex. filter_by&#x3D;flag:dataset
     * @param expand ex. expand&#x3D;creator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAllByProject(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<ActivitiesDTO>;
    public findAllByProject(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ActivitiesDTO>>;
    public findAllByProject(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ActivitiesDTO>>;
    public findAllByProject(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findAllByProject.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ActivitiesDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/activities`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findAllByUser(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public findAllByUser(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public findAllByUser(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public findAllByUser(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findByProjectID(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public findByProjectID(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public findByProjectID(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public findByProjectID(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findByProjectID.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findDataSetsInProjectID(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public findDataSetsInProjectID(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public findDataSetsInProjectID(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public findDataSetsInProjectID(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findDataSetsInProjectID.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/getContent`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findMembersByProjectID(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public findMembersByProjectID(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public findMembersByProjectID(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public findMembersByProjectID(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling findMembersByProjectID.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/projectMembers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get commands for this environment
     * 
     * @param version 
     * @param projectId 
     * @param offset 
     * @param limit 
     * @param sortBy ex. sort_by&#x3D;ID:asc,date_created:desc
     * @param filterBy ex. filter_by&#x3D;op:create
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public get(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public get(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public get(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public get(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling get.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling get.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/commands`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all commands for this library
     * 
     * @param library 
     * @param version 
     * @param projectId 
     * @param offset 
     * @param limit 
     * @param sortBy ex. sort_by&#x3D;ID:asc,date_created:desc
     * @param filterBy ex. filter_by&#x3D;op:create
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public get1(library: string, version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<CommandDTO>;
    public get1(library: string, version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CommandDTO>>;
    public get1(library: string, version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CommandDTO>>;
    public get1(library: string, version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling get1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling get1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling get1.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CommandDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}/commands`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the python libraries installed in this environment
     * 
     * @param version 
     * @param projectId 
     * @param offset 
     * @param limit 
     * @param sortBy ex. sort_by&#x3D;ID:asc,dependency:desc
     * @param filterBy ex. filter_by&#x3D;preinstalled:1
     * @param expand ex. expand&#x3D;commands
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public get2(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<LibraryDTO>;
    public get2(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LibraryDTO>>;
    public get2(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LibraryDTO>>;
    public get2(version: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling get2.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling get2.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LibraryDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the python environment for specific python version
     * 
     * @param version 
     * @param projectId 
     * @param expand ex. expand&#x3D;commands
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public get3(version: string, projectId: number, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<EnvironmentDTO>;
    public get3(version: string, projectId: number, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EnvironmentDTO>>;
    public get3(version: string, projectId: number, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EnvironmentDTO>>;
    public get3(version: string, projectId: number, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling get3.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling get3.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<EnvironmentDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all python environments for this project
     * 
     * @param projectId 
     * @param expand ex. expand&#x3D;commands
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAll(projectId: number, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<EnvironmentDTO>;
    public getAll(projectId: number, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EnvironmentDTO>>;
    public getAll(projectId: number, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EnvironmentDTO>>;
    public getAll(projectId: number, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAll.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<EnvironmentDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of all jobs for this project
     * 
     * @param projectId 
     * @param offset 
     * @param limit 
     * @param sortBy ex. sort_by&#x3D;date_created:desc,name:asc
     * @param filterBy ex. filter_by&#x3D;jobtype:spark&amp;filter_by&#x3D;date_created_gt:2018-12-25T17:12:10
     * @param expand ex. expand&#x3D;creator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAll1(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public getAll1(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public getAll1(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public getAll1(projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAll1.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllNotebookServersInProject(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getAllNotebookServersInProject(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getAllNotebookServersInProject(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getAllNotebookServersInProject(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAllNotebookServersInProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllProjects(observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getAllProjects(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getAllProjects(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getAllProjects(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/getAll`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param appId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAppInfo(appId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getAppInfo(appId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getAppInfo(appId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getAppInfo(appId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getAppInfo.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getAppInfo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(appId))}/appinfo`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get commands by id
     * 
     * @param commandId 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getByName(commandId: number, version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<CommandDTO>;
    public getByName(commandId: number, version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CommandDTO>>;
    public getByName(commandId: number, version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CommandDTO>>;
    public getByName(commandId: number, version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (commandId === null || commandId === undefined) {
            throw new Error('Required parameter commandId was null or undefined when calling getByName.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getByName.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getByName.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CommandDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/commands/${encodeURIComponent(String(commandId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get command by id
     * 
     * @param library 
     * @param commandId 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getByName1(library: string, commandId: number, version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<CommandDTO>;
    public getByName1(library: string, commandId: number, version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CommandDTO>>;
    public getByName1(library: string, commandId: number, version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CommandDTO>>;
    public getByName1(library: string, commandId: number, version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling getByName1.');
        }

        if (commandId === null || commandId === undefined) {
            throw new Error('Required parameter commandId was null or undefined when calling getByName1.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getByName1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getByName1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<CommandDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}/commands/${encodeURIComponent(String(commandId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the a python library installed in this environment
     * 
     * @param library 
     * @param version 
     * @param projectId 
     * @param expand ex. expand&#x3D;commands
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getByName2(library: string, version: string, projectId: number, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<LibraryDTO>;
    public getByName2(library: string, version: string, projectId: number, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LibraryDTO>>;
    public getByName2(library: string, version: string, projectId: number, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LibraryDTO>>;
    public getByName2(library: string, version: string, projectId: number, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling getByName2.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getByName2.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getByName2.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LibraryDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCurrentMultiplicator(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getCurrentMultiplicator(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getCurrentMultiplicator(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getCurrentMultiplicator(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getCurrentMultiplicator.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/multiplicators`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param inodeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDatasetInfo(inodeId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getDatasetInfo(inodeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getDatasetInfo(inodeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getDatasetInfo(inodeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling getDatasetInfo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/getDatasetInfo/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param inodeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDatasetInfo1(projectId: number, inodeId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getDatasetInfo1(projectId: number, inodeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getDatasetInfo1(projectId: number, inodeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getDatasetInfo1(projectId: number, inodeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDatasetInfo1.');
        }

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling getDatasetInfo1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/getInodeInfo/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDirContent(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getDirContent(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getDirContent(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getDirContent(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getDirContent.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getDirContent.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/getContent/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find Execution by Id
     * 
     * @param id execution id
     * @param name 
     * @param projectId 
     * @param sortBy ex. sort_by&#x3D;submissiontime:desc,id:asc
     * @param filterBy state and finalstatus accept also neq (not equals) ex. filter_by&#x3D;state:running&amp;filter_by&#x3D;state_neq:new&amp;filter_by&#x3D;submissiontime:2018-12-25T17:12:10.058
     * @param expand ex. expand&#x3D;creator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecution(id: number, name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<ExecutionDTO>;
    public getExecution(id: number, name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExecutionDTO>>;
    public getExecution(id: number, name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExecutionDTO>>;
    public getExecution(id: number, name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getExecution.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getExecution.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getExecution.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExecutionDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/executions/${encodeURIComponent(String(id))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a list of executions for the job.
     * 
     * @param name 
     * @param projectId 
     * @param offset 
     * @param limit 
     * @param sortBy ex. sort_by&#x3D;submissiontime:desc,id:asc
     * @param filterBy state and finalstatus accept also neq (not equals) ex. filter_by&#x3D;state:running&amp;filter_by&#x3D;state_neq:new&amp;filter_by&#x3D;submissiontime:2018-12-25T17:12:10.058
     * @param expand ex. expand&#x3D;creator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExecutions(name: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<ExecutionDTO>;
    public getExecutions(name: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ExecutionDTO>>;
    public getExecutions(name: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ExecutionDTO>>;
    public getExecutions(name: string, projectId: number, offset?: number, limit?: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getExecutions.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getExecutions.');
        }






        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ExecutionDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/executions`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param publicDSId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getExtendedDetails(publicDSId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getExtendedDetails(publicDSId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getExtendedDetails(publicDSId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getExtendedDetails(publicDSId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (publicDSId === null || publicDSId === undefined) {
            throw new Error('Required parameter publicDSId was null or undefined when calling getExtendedDetails.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getExtendedDetails.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/transfers/${encodeURIComponent(String(publicDSId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get specific featuregroup from a specific featurestore
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Preview feature data of a featuregroup
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturegroupPreview>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturegroupPreview>>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturegroupPreview>>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupPreview.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupPreview.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupPreview.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturegroupPreview>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/preview`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the SQL schema of a featuregroup
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<RowValueQueryResult>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RowValueQueryResult>>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RowValueQueryResult>>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupSchema.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupSchema.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupSchema.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RowValueQueryResult>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/schema`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of feature groups for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturegroupDTO>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturegroupDTO>>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturegroupDTO>>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeaturegroupsForFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturegroupsForFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturegroupDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore with specific Id
     * 
     * @param featurestoreId Id of the featurestore
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreDTO>;
    public getFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreDTO>>;
    public getFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreDTO>>;
    public getFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore with specific name
     * 
     * @param featurestoreName Id of the featurestore
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreDTO>;
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreDTO>>;
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreDTO>>;
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreName === null || featurestoreName === undefined) {
            throw new Error('Required parameter featurestoreName was null or undefined when calling getFeaturestoreByName.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestoreByName.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/getByName/${encodeURIComponent(String(featurestoreName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore Metadata
     * 
     * @param featurestoreName 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreClientSettingsDTO>;
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreName === null || featurestoreName === undefined) {
            throw new Error('Required parameter featurestoreName was null or undefined when calling getFeaturestoreId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestoreId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreClientSettingsDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreName))}/metadata`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore settings
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestoreSettings(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreClientSettingsDTO>;
    public getFeaturestoreSettings(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreSettings(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreSettings(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestoreSettings.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreClientSettingsDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/settings`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of feature stores for the project
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestores(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturestoreDTO>>;
    public getFeaturestores(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturestoreDTO>>>;
    public getFeaturestores(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturestoreDTO>>>;
    public getFeaturestores(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestores.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturestoreDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFile(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getFile(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getFile(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getFile(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling getFile.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFile.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/getFile/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getGitStatusOfJupyterRepo(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getGitStatusOfJupyterRepo(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getGitStatusOfJupyterRepo(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getGitStatusOfJupyterRepo(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getGitStatusOfJupyterRepo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/git/status`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the job with requested ID
     * 
     * @param name 
     * @param projectId 
     * @param sortBy ex. sort_by&#x3D;date_created:desc,name:asc
     * @param filterBy ex. filter_by&#x3D;jobtype:spark&amp;filter_by&#x3D;date_created_gt:2018-12-25T17:12:10
     * @param expand ex. expand&#x3D;creator
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJob(name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public getJob(name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public getJob(name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public getJob(name: string, projectId: number, sortBy?: string, filterBy?: Array<string>, expand?: Array<string>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJob.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getJob.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (sortBy !== undefined && sortBy !== null) {
            queryParameters = queryParameters.set('sort_by', <any>sortBy);
        }
        if (filterBy) {
            filterBy.forEach((element) => {
                queryParameters = queryParameters.append('filter_by', <any>element);
            })
        }
        if (expand) {
            expand.forEach((element) => {
                queryParameters = queryParameters.append('expand', <any>element);
            })
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param appId 
     * @param isLivy 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getJobUI(appId: string, isLivy: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getJobUI(appId: string, isLivy: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getJobUI(appId: string, isLivy: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getJobUI(appId: string, isLivy: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getJobUI.');
        }

        if (isLivy === null || isLivy === undefined) {
            throw new Error('Required parameter isLivy was null or undefined when calling getJobUI.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getJobUI.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(appId))}/ui/${encodeURIComponent(String(isLivy))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve log of given execution and type
     * 
     * @param id 
     * @param type 
     * @param name 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getLog(id: number, type: string, name: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<JobLogDTO>;
    public getLog(id: number, type: string, name: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobLogDTO>>;
    public getLog(id: number, type: string, name: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobLogDTO>>;
    public getLog(id: number, type: string, name: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getLog.');
        }

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling getLog.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getLog.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getLog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<JobLogDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/executions/${encodeURIComponent(String(id))}/log/${encodeURIComponent(String(type))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param inodeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMoreInfo(projectId: number, inodeId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getMoreInfo(projectId: number, inodeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getMoreInfo(projectId: number, inodeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getMoreInfo(projectId: number, inodeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getMoreInfo.');
        }

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling getMoreInfo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/getMoreInfo/${encodeURIComponent(String(type))}/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param inodeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMoreInfo1(inodeId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getMoreInfo1(inodeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getMoreInfo1(inodeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getMoreInfo1(inodeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling getMoreInfo1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/getMoreInfo/${encodeURIComponent(String(type))}/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMoreInfo2(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getMoreInfo2(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getMoreInfo2(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getMoreInfo2(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getMoreInfo2.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/getMoreInfo/proj/${encodeURIComponent(String(projectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get online featurestore storage connector for this feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getOnlineFeaturestoreStorageConnector.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getOnlineFeaturestoreStorageConnector.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/onlinefeaturestore`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPia(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getPia(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getPia(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getPia(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getPia.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/pia`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectByName(projectName: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getProjectByName(projectName: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getProjectByName(projectName: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getProjectByName(projectName: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectName === null || projectName === undefined) {
            throw new Error('Required parameter projectName was null or undefined when calling getProjectByName.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/getProjectInfo/${encodeURIComponent(String(projectName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectContents(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getProjectContents(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getProjectContents(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getProjectContents(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectContents.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/transfers`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getProjectSharedWith(projectId: number, body?: DataSetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getProjectSharedWith(projectId: number, body?: DataSetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getProjectSharedWith(projectId: number, body?: DataSetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getProjectSharedWith(projectId: number, body?: DataSetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getProjectSharedWith.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/projectsSharedWith`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param inodeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getReadmeByInodeId(inodeId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getReadmeByInodeId(inodeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getReadmeByInodeId(inodeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getReadmeByInodeId(inodeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling getReadmeByInodeId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/readme/byInodeId/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param remoteURI 
     * @param keyName 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRemoteGitBranches(projectId: number, remoteURI?: string, keyName?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getRemoteGitBranches(projectId: number, remoteURI?: string, keyName?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getRemoteGitBranches(projectId: number, remoteURI?: string, keyName?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getRemoteGitBranches(projectId: number, remoteURI?: string, keyName?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getRemoteGitBranches.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (remoteURI !== undefined && remoteURI !== null) {
            queryParameters = queryParameters.set('remoteURI', <any>remoteURI);
        }
        if (keyName !== undefined && keyName !== null) {
            queryParameters = queryParameters.set('keyName', <any>keyName);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/git/branches`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param topic 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSchema(topic: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getSchema(topic: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getSchema(topic: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getSchema(topic: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling getSchema.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSchema.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/${encodeURIComponent(String(topic))}/schema`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param schemaName 
     * @param schemaVersion 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSchemaContent(schemaName: string, schemaVersion: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getSchemaContent(schemaName: string, schemaVersion: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getSchemaContent(schemaName: string, schemaVersion: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getSchemaContent(schemaName: string, schemaVersion: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (schemaName === null || schemaName === undefined) {
            throw new Error('Required parameter schemaName was null or undefined when calling getSchemaContent.');
        }

        if (schemaVersion === null || schemaVersion === undefined) {
            throw new Error('Required parameter schemaVersion was null or undefined when calling getSchemaContent.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getSchemaContent.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/showSchema/${encodeURIComponent(String(schemaName))}/${encodeURIComponent(String(schemaVersion))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get info about a serving instance for the project
     * 
     * @param servingId Id of the Serving instance
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServing(servingId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<RepresentsAServingModel>;
    public getServing(servingId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RepresentsAServingModel>>;
    public getServing(servingId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RepresentsAServingModel>>;
    public getServing(servingId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (servingId === null || servingId === undefined) {
            throw new Error('Required parameter servingId was null or undefined when calling getServing.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getServing.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RepresentsAServingModel>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/serving/${encodeURIComponent(String(servingId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of serving instances for the project
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getServings(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<RepresentsAServingModel>>;
    public getServings(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<RepresentsAServingModel>>>;
    public getServings(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<RepresentsAServingModel>>>;
    public getServings(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getServings.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<RepresentsAServingModel>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/serving`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a storage connector with a specific id and type from a featurestore
     * 
     * @param connectorType storage connector type
     * @param connectorId Id of the storage connector
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling getStorageConnectorWithId.');
        }

        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling getStorageConnectorWithId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getStorageConnectorWithId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getStorageConnectorWithId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}/${encodeURIComponent(String(connectorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all storage connectors of a feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorageConnectors(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectors(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectors(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectors(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getStorageConnectors.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getStorageConnectors.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturestoreStorageConnectorDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all storage connectors of a specific type of a feature store
     * 
     * @param connectorType storage connector type
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling getStorageConnectorsOfType.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getStorageConnectorsOfType.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getStorageConnectorsOfType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturestoreStorageConnectorDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the running TensorBoard of the logged in user in this project
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTensorBoard(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getTensorBoard(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getTensorBoard(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getTensorBoard(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTensorBoard.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/tensorboard`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param appId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTensorBoardUrls(appId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getTensorBoardUrls(appId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getTensorBoardUrls(appId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getTensorBoardUrls(appId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getTensorBoardUrls.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTensorBoardUrls.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(appId))}/tensorboard`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Kafka topic details.
     * 
     * @param topic 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTopic(topic: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getTopic(topic: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getTopic(topic: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getTopic(topic: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling getTopic.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTopic.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get ACL metadata specified by id.
     * 
     * @param topic 
     * @param id 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTopicAcl(topic: string, id: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getTopicAcl(topic: string, id: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getTopicAcl(topic: string, id: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getTopicAcl(topic: string, id: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling getTopicAcl.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTopicAcl.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTopicAcl.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/acls/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all ACLs for a specified topic.
     * 
     * @param topic 
     * @param projectId 
     * @param body 
     * @param offset 
     * @param limit 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTopicAcls(topic: string, projectId: number, body?: AclsBeanParam, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getTopicAcls(topic: string, projectId: number, body?: AclsBeanParam, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getTopicAcls(topic: string, projectId: number, body?: AclsBeanParam, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getTopicAcls(topic: string, projectId: number, body?: AclsBeanParam, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling getTopicAcls.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTopicAcls.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/acls`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve Kafka topics metadata .
     * 
     * @param projectId 
     * @param body 
     * @param offset 
     * @param limit 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTopics(projectId: number, body?: TopicsBeanParam, offset?: number, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getTopics(projectId: number, body?: TopicsBeanParam, offset?: number, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getTopics(projectId: number, body?: TopicsBeanParam, offset?: number, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getTopics(projectId: number, body?: TopicsBeanParam, offset?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTopics.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a training datasets with a specific id from a featurestore
     * 
     * @param trainingdatasetid Id of the training dataset
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (trainingdatasetid === null || trainingdatasetid === undefined) {
            throw new Error('Required parameter trainingdatasetid was null or undefined when calling getTrainingDatasetWithId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getTrainingDatasetWithId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTrainingDatasetWithId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets/${encodeURIComponent(String(trainingdatasetid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of training datasets for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TrainingDatasetDTO>>;
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TrainingDatasetDTO>>>;
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TrainingDatasetDTO>>>;
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getTrainingDatasetsForFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTrainingDatasetsForFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TrainingDatasetDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch the result of a Deequ data validation job
     * 
     * @param featuregroupId 
     * @param featureStoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<ValidationResult>;
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ValidationResult>>;
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ValidationResult>>;
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getValidationResult.');
        }

        if (featureStoreId === null || featureStoreId === undefined) {
            throw new Error('Required parameter featureStoreId was null or undefined when calling getValidationResult.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getValidationResult.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ValidationResult>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featureStoreId))}/datavalidation/${encodeURIComponent(String(featuregroupId))}/result`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get previously stored Deequ validation rules
     * 
     * @param featuregroupId 
     * @param featureStoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<ConstraintGroupDTO>;
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConstraintGroupDTO>>;
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConstraintGroupDTO>>;
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getValidationRules.');
        }

        if (featureStoreId === null || featureStoreId === undefined) {
            throw new Error('Required parameter featureStoreId was null or undefined when calling getValidationRules.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getValidationRules.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ConstraintGroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featureStoreId))}/datavalidation/${encodeURIComponent(String(featuregroupId))}/rules`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param appId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getYarnUI(appId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public getYarnUI(appId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public getYarnUI(appId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public getYarnUI(appId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling getYarnUI.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getYarnUI.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(appId))}/yarnui`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Make inference
     * 
     * @param modelName Name of the model to query
     * @param version Version of the model to query
     * @param verb Type of query
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public infer(modelName: string, version: string, verb: string, projectId: number, body?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public infer(modelName: string, version: string, verb: string, projectId: number, body?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public infer(modelName: string, version: string, verb: string, projectId: number, body?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public infer(modelName: string, version: string, verb: string, projectId: number, body?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (modelName === null || modelName === undefined) {
            throw new Error('Required parameter modelName was null or undefined when calling infer.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling infer.');
        }

        if (verb === null || verb === undefined) {
            throw new Error('Required parameter verb was null or undefined when calling infer.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling infer.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/inference/models/${encodeURIComponent(String(modelName))}${encodeURIComponent(String(version))}${encodeURIComponent(String(verb))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Inspect Spark user program and return SparkJobConfiguration
     * 
     * @param jobtype spark job type
     * @param path path
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public inspect(jobtype: string, path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<SparkJobConfiguration>;
    public inspect(jobtype: string, path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<SparkJobConfiguration>>;
    public inspect(jobtype: string, path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<SparkJobConfiguration>>;
    public inspect(jobtype: string, path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (jobtype === null || jobtype === undefined) {
            throw new Error('Required parameter jobtype was null or undefined when calling inspect.');
        }

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling inspect.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling inspect.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (path !== undefined && path !== null) {
            queryParameters = queryParameters.set('path', <any>path);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<SparkJobConfiguration>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(jobtype))}/inspection`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Install a python library in the environment
     * 
     * @param library 
     * @param version2 
     * @param projectId 
     * @param packageManager 
     * @param version 
     * @param channel 
     * @param machine 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public install(library: string, version2: string, projectId: number, packageManager?: string, version?: string, channel?: string, machine?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public install(library: string, version2: string, projectId: number, packageManager?: string, version?: string, channel?: string, machine?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public install(library: string, version2: string, projectId: number, packageManager?: string, version?: string, channel?: string, machine?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public install(library: string, version2: string, projectId: number, packageManager?: string, version?: string, channel?: string, machine?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling install.');
        }

        if (version2 === null || version2 === undefined) {
            throw new Error('Required parameter version2 was null or undefined when calling install.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling install.');
        }





        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (packageManager !== undefined && packageManager !== null) {
            queryParameters = queryParameters.set('package_manager', <any>packageManager);
        }
        if (version !== undefined && version !== null) {
            queryParameters = queryParameters.set('version', <any>version);
        }
        if (channel !== undefined && channel !== null) {
            queryParameters = queryParameters.set('channel', <any>channel);
        }
        if (machine !== undefined && machine !== null) {
            queryParameters = queryParameters.set('machine', <any>machine);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public isDir(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public isDir(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public isDir(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public isDir(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling isDir.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling isDir.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/isDir/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public isDir1(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public isDir1(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public isDir1(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public isDir1(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling isDir1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling isDir1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/localfs/isDir/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public isRunning(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public isRunning(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public isRunning(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public isRunning(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling isRunning.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/running`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public listSchemasForTopics(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public listSchemasForTopics(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public listSchemasForTopics(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public listSchemasForTopics(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling listSchemasForTopics.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/schemas`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public livySessions(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public livySessions(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public livySessions(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public livySessions(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling livySessions.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/livy/sessions`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveFile(projectId: number, body?: MoveDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public moveFile(projectId: number, body?: MoveDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public moveFile(projectId: number, body?: MoveDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public moveFile(projectId: number, body?: MoveDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling moveFile.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/move`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Upload json input for featurestore-util jobs
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling newFeaturestoreUtil.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/util`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create an environment from version or export an environment as yaml file
     * 
     * @param version 
     * @param projectId 
     * @param action 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public post(version: string, projectId: number, action?: string, observe?: 'body', reportProgress?: boolean): Observable<EnvironmentDTO>;
    public post(version: string, projectId: number, action?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EnvironmentDTO>>;
    public post(version: string, projectId: number, action?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EnvironmentDTO>>;
    public post(version: string, projectId: number, action?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling post.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling post.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (action !== undefined && action !== null) {
            queryParameters = queryParameters.set('action', <any>action);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<EnvironmentDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create an environment from yaml file
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postYml(projectId: number, body?: EnvironmentYmlDTO, observe?: 'body', reportProgress?: boolean): Observable<EnvironmentDTO>;
    public postYml(projectId: number, body?: EnvironmentYmlDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<EnvironmentDTO>>;
    public postYml(projectId: number, body?: EnvironmentYmlDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<EnvironmentDTO>>;
    public postYml(projectId: number, body?: EnvironmentYmlDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling postYml.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<EnvironmentDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public publish(projectId: number, body?: InodeIdDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public publish(projectId: number, body?: InodeIdDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public publish(projectId: number, body?: InodeIdDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public publish(projectId: number, body?: InodeIdDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling publish.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/uploads`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create or Update a Job.
     * 
     * @param name name
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public put(name: string, projectId: number, body?: JobConfiguration, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public put(name: string, projectId: number, body?: JobConfiguration, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public put(name: string, projectId: number, body?: JobConfiguration, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public put(name: string, projectId: number, body?: JobConfiguration, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling put.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling put.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public quotasByProjectID(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public quotasByProjectID(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public quotasByProjectID(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public quotasByProjectID(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling quotasByProjectID.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/quotas`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param projectName 
     * @param inodeId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public quotasByProjectID1(projectId: number, projectName: string, inodeId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public quotasByProjectID1(projectId: number, projectName: string, inodeId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public quotasByProjectID1(projectId: number, projectName: string, inodeId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public quotasByProjectID1(projectId: number, projectName: string, inodeId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling quotasByProjectID1.');
        }

        if (projectName === null || projectName === undefined) {
            throw new Error('Required parameter projectName was null or undefined when calling quotasByProjectID1.');
        }

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling quotasByProjectID1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/importPublicDataset/${encodeURIComponent(String(projectName))}/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param inodeId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public rejectRequest(inodeId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public rejectRequest(inodeId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public rejectRequest(inodeId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public rejectRequest(inodeId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling rejectRequest.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling rejectRequest.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/reject/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove ACL specified by id.
     * 
     * @param topic 
     * @param id 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeAclsFromTopic(topic: string, id: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeAclsFromTopic(topic: string, id: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeAclsFromTopic(topic: string, id: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeAclsFromTopic(topic: string, id: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling removeAclsFromTopic.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling removeAclsFromTopic.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removeAclsFromTopic.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/acls/${encodeURIComponent(String(id))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param fileName 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeCorrupted(fileName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeCorrupted(fileName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeCorrupted(fileName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeCorrupted(fileName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling removeCorrupted.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removeCorrupted.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/corrupted/${encodeURIComponent(String(fileName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param email 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeMembersByID(email: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeMembersByID(email: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeMembersByID(email: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeMembersByID(email: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling removeMembersByID.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removeMembersByID.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/projectMembers/${encodeURIComponent(String(email))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeProjectAndFiles(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeProjectAndFiles(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeProjectAndFiles(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeProjectAndFiles(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removeProjectAndFiles.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/delete`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param publicDSId 
     * @param clean delete dataset
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removePublic(publicDSId: string, clean: boolean, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removePublic(publicDSId: string, clean: boolean, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removePublic(publicDSId: string, clean: boolean, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removePublic(publicDSId: string, clean: boolean, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (publicDSId === null || publicDSId === undefined) {
            throw new Error('Required parameter publicDSId was null or undefined when calling removePublic.');
        }

        if (clean === null || clean === undefined) {
            throw new Error('Required parameter clean was null or undefined when calling removePublic.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removePublic.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (clean !== undefined && clean !== null) {
            queryParameters = queryParameters.set('clean', <any>clean);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/transfers/${encodeURIComponent(String(publicDSId))}/cancel`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param inodeId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removePublic1(inodeId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removePublic1(inodeId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removePublic1(inodeId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removePublic1(inodeId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (inodeId === null || inodeId === undefined) {
            throw new Error('Required parameter inodeId was null or undefined when calling removePublic1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removePublic1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/delacluster/${encodeURIComponent(String(inodeId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a Kafka topic.
     * 
     * @param topic 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeTopic(topic: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removeTopic(topic: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removeTopic(topic: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removeTopic(topic: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling removeTopic.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removeTopic.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param fileName 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removedataSetdir(fileName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removedataSetdir(fileName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removedataSetdir(fileName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removedataSetdir(fileName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling removedataSetdir.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removedataSetdir.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/${encodeURIComponent(String(fileName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param fileName 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removedataSetdir1(fileName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removedataSetdir1(fileName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removedataSetdir1(fileName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removedataSetdir1(fileName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling removedataSetdir1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removedataSetdir1.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/localfs/${encodeURIComponent(String(fileName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param fileName 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removefile(fileName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public removefile(fileName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public removefile(fileName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public removefile(fileName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling removefile.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling removefile.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/file/${encodeURIComponent(String(fileName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retry log aggregation of given execution and type
     * 
     * @param id 
     * @param type 
     * @param name 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public retryLog(id: number, type: string, name: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<JobLogDTO>;
    public retryLog(id: number, type: string, name: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobLogDTO>>;
    public retryLog(id: number, type: string, name: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobLogDTO>>;
    public retryLog(id: number, type: string, name: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling retryLog.');
        }

        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling retryLog.');
        }

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling retryLog.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling retryLog.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<JobLogDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/executions/${encodeURIComponent(String(id))}/log/${encodeURIComponent(String(type))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search for libraries using conda or pip package managers
     * 
     * @param search 
     * @param version 
     * @param projectId 
     * @param query 
     * @param channel 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public search(search: string, version: string, projectId: number, query?: string, channel?: string, observe?: 'body', reportProgress?: boolean): Observable<LibrarySearchDTO>;
    public search(search: string, version: string, projectId: number, query?: string, channel?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<LibrarySearchDTO>>;
    public search(search: string, version: string, projectId: number, query?: string, channel?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<LibrarySearchDTO>>;
    public search(search: string, version: string, projectId: number, query?: string, channel?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (search === null || search === undefined) {
            throw new Error('Required parameter search was null or undefined when calling search.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling search.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling search.');
        }



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (query !== undefined && query !== null) {
            queryParameters = queryParameters.set('query', <any>query);
        }
        if (channel !== undefined && channel !== null) {
            queryParameters = queryParameters.set('channel', <any>channel);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<LibrarySearchDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(search))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create project secret directory in Airflow home
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public secretDir(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public secretDir(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public secretDir(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public secretDir(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling secretDir.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/airflow/secretDir`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set permissions (potentially with sticky bit) for datasets
     * Allow data scientists to create and modify own files in dataset.
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setPermissions(projectId: number, body?: DataSetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public setPermissions(projectId: number, body?: DataSetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public setPermissions(projectId: number, body?: DataSetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public setPermissions(projectId: number, body?: DataSetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling setPermissions.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/permissions`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public settings(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public settings(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public settings(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public settings(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling settings.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/settings`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public share(projectId: number, body?: InodeIdDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public share(projectId: number, body?: InodeIdDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public share(projectId: number, body?: InodeIdDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public share(projectId: number, body?: InodeIdDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling share.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/delacluster`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public shareDataSet(projectId: number, body?: DataSetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public shareDataSet(projectId: number, body?: DataSetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public shareDataSet(projectId: number, body?: DataSetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public shareDataSet(projectId: number, body?: DataSetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling shareDataSet.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/shareDataSet`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Share a Kafka topic with a project.
     * 
     * @param topic 
     * @param destProjectId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public shareTopic(topic: string, destProjectId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public shareTopic(topic: string, destProjectId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public shareTopic(topic: string, destProjectId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public shareTopic(topic: string, destProjectId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling shareTopic.');
        }

        if (destProjectId === null || destProjectId === undefined) {
            throw new Error('Required parameter destProjectId was null or undefined when calling shareTopic.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling shareTopic.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/shared/${encodeURIComponent(String(destProjectId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param publicDSId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public showManifest(publicDSId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public showManifest(publicDSId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public showManifest(publicDSId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public showManifest(publicDSId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (publicDSId === null || publicDSId === undefined) {
            throw new Error('Required parameter publicDSId was null or undefined when calling showManifest.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling showManifest.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/transfers/${encodeURIComponent(String(publicDSId))}/manifest`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param publicDSId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startDownload(publicDSId: string, projectId: number, body?: Download, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public startDownload(publicDSId: string, projectId: number, body?: Download, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public startDownload(publicDSId: string, projectId: number, body?: Download, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public startDownload(publicDSId: string, projectId: number, body?: Download, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (publicDSId === null || publicDSId === undefined) {
            throw new Error('Required parameter publicDSId was null or undefined when calling startDownload.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startDownload.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dela/downloads/${encodeURIComponent(String(publicDSId))}/manifest`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startNotebookServer(projectId: number, body?: JupyterSettings, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public startNotebookServer(projectId: number, body?: JupyterSettings, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public startNotebookServer(projectId: number, body?: JupyterSettings, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public startNotebookServer(projectId: number, body?: JupyterSettings, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startNotebookServer.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/start`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start or stop a Serving instance
     * 
     * @param servingId ID of the Serving instance to start/stop
     * @param action Action
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startOrStop(servingId: number, action: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public startOrStop(servingId: number, action: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public startOrStop(servingId: number, action: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public startOrStop(servingId: number, action: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (servingId === null || servingId === undefined) {
            throw new Error('Required parameter servingId was null or undefined when calling startOrStop.');
        }

        if (action === null || action === undefined) {
            throw new Error('Required parameter action was null or undefined when calling startOrStop.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startOrStop.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (action !== undefined && action !== null) {
            queryParameters = queryParameters.set('action', <any>action);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/serving/${encodeURIComponent(String(servingId))}`,
            null,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Start a new TensorBoard for the logged in user
     * 
     * @param elasticId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public startTensorBoard(elasticId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public startTensorBoard(elasticId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public startTensorBoard(elasticId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public startTensorBoard(elasticId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (elasticId === null || elasticId === undefined) {
            throw new Error('Required parameter elasticId was null or undefined when calling startTensorBoard.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling startTensorBoard.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/tensorboard/${encodeURIComponent(String(elasticId))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param appId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stopLivySession(appId: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public stopLivySession(appId: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public stopLivySession(appId: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public stopLivySession(appId: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (appId === null || appId === undefined) {
            throw new Error('Required parameter appId was null or undefined when calling stopLivySession.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling stopLivySession.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/livy/sessions/${encodeURIComponent(String(appId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stopNotebookServer(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public stopNotebookServer(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public stopNotebookServer(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public stopNotebookServer(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling stopNotebookServer.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/stop`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Stop the running TensorBoard for the logged in user
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public stopTensorBoard(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public stopTensorBoard(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public stopTensorBoard(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public stopTensorBoard(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling stopTensorBoard.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/tensorboard`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Generate a JWT for Airflow usage and store it in project&#x27;s secret directory in Airflow
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public storeAirflowJWT(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public storeAirflowJWT(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public storeAirflowJWT(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public storeAirflowJWT(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling storeAirflowJWT.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/airflow/jwt`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Synchornize Hive Table with the feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling syncWithFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling syncWithFeaturestore.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/sync`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param templateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public testMethod1(path: string, projectId: number, templateId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public testMethod1(path: string, projectId: number, templateId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public testMethod1(path: string, projectId: number, templateId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public testMethod1(path: string, projectId: number, templateId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling testMethod1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling testMethod1.');
        }


        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (templateId !== undefined && templateId !== null) {
            queryParameters = queryParameters.set('templateId', <any>templateId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/upload/${encodeURIComponent(String(path))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get list of projects that a topic has been shared with.
     * 
     * @param topic 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public topicIsSharedTo(topic: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public topicIsSharedTo(topic: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public topicIsSharedTo(topic: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public topicIsSharedTo(topic: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling topicIsSharedTo.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling topicIsSharedTo.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/shared`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Uninstall a python library from the environment
     * 
     * @param library 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uninstall(library: string, version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public uninstall(library: string, version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public uninstall(library: string, version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public uninstall(library: string, version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling uninstall.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling uninstall.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling uninstall.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel a job&#x27;s schedule.
     * 
     * @param name 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unscheduleJob(name: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public unscheduleJob(name: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public unscheduleJob(name: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public unscheduleJob(name: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling unscheduleJob.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling unscheduleJob.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/schedule`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unshareDataSet(projectId: number, body?: DataSetDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public unshareDataSet(projectId: number, body?: DataSetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public unshareDataSet(projectId: number, body?: DataSetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public unshareDataSet(projectId: number, body?: DataSetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling unshareDataSet.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/unshareDataSet`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Unshare Kafka topic from a project (specified as destProjectId).
     * 
     * @param topic 
     * @param destProjectId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unshareTopicFromProject(topic: string, destProjectId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public unshareTopicFromProject(topic: string, destProjectId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public unshareTopicFromProject(topic: string, destProjectId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public unshareTopicFromProject(topic: string, destProjectId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling unshareTopicFromProject.');
        }

        if (destProjectId === null || destProjectId === undefined) {
            throw new Error('Required parameter destProjectId was null or undefined when calling unshareTopicFromProject.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling unshareTopicFromProject.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/shared/${encodeURIComponent(String(destProjectId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Unshare Kafka topic from all projects.
     * 
     * @param topic 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unshareTopicFromProjects(topic: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public unshareTopicFromProjects(topic: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public unshareTopicFromProjects(topic: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public unshareTopicFromProjects(topic: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling unshareTopicFromProjects.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling unshareTopicFromProjects.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/shared`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public unzip(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public unzip(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public unzip(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public unzip(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling unzip.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling unzip.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/unzip/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update commands for this library
     * 
     * @param library 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public update(library: string, version: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public update(library: string, version: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public update(library: string, version: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public update(library: string, version: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (library === null || library === undefined) {
            throw new Error('Required parameter library was null or undefined when calling update.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling update.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling update.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/python/environments/${encodeURIComponent(String(version))}/libraries/${encodeURIComponent(String(library))}/commands`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update featuregroup contents
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param updateMetadata updateMetadata
     * @param updateStats updateStats
     * @param enableOnline enableOnline
     * @param disableOnline disableOnline
     * @param updateStatsSettings updateStatsSettings
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling updateFeaturegroup.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateFeaturegroup.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateFeaturegroup.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateMetadata !== undefined && updateMetadata !== null) {
            queryParameters = queryParameters.set('updateMetadata', <any>updateMetadata);
        }
        if (updateStats !== undefined && updateStats !== null) {
            queryParameters = queryParameters.set('updateStats', <any>updateStats);
        }
        if (enableOnline !== undefined && enableOnline !== null) {
            queryParameters = queryParameters.set('enableOnline', <any>enableOnline);
        }
        if (disableOnline !== undefined && disableOnline !== null) {
            queryParameters = queryParameters.set('disableOnline', <any>disableOnline);
        }
        if (updateStatsSettings !== undefined && updateStatsSettings !== null) {
            queryParameters = queryParameters.set('updateStatsSettings', <any>updateStatsSettings);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateNotebookServer(projectId: number, body?: JupyterSettings, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateNotebookServer(projectId: number, body?: JupyterSettings, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateNotebookServer(projectId: number, body?: JupyterSettings, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateNotebookServer(projectId: number, body?: JupyterSettings, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateNotebookServer.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jupyter/update`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updatePia(projectId: number, body?: Pia, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updatePia(projectId: number, body?: Pia, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updatePia(projectId: number, body?: Pia, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updatePia(projectId: number, body?: Pia, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updatePia.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/pia`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateProject(projectId: number, body?: ProjectDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateProject(projectId: number, body?: ProjectDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateProject(projectId: number, body?: ProjectDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateProject(projectId: number, body?: ProjectDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateProject.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param email 
     * @param projectId 
     * @param role 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateRoleByEmail(email: string, projectId: number, role?: string, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateRoleByEmail(email: string, projectId: number, role?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateRoleByEmail(email: string, projectId: number, role?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateRoleByEmail(email: string, projectId: number, role?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling updateRoleByEmail.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateRoleByEmail.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (role !== undefined) {
            formParams = formParams.append('role', <any>role) || formParams;
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/projectMembers/${encodeURIComponent(String(email))}`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create/Update job&#x27;s schedule.
     * 
     * @param name 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSchedule(name: string, projectId: number, body?: ScheduleDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateSchedule(name: string, projectId: number, body?: ScheduleDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateSchedule(name: string, projectId: number, body?: ScheduleDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateSchedule(name: string, projectId: number, body?: ScheduleDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling updateSchedule.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateSchedule.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/jobs/${encodeURIComponent(String(name))}/schedule`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param topic 
     * @param version 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSchemaVersion(topic: string, version: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateSchemaVersion(topic: string, version: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateSchemaVersion(topic: string, version: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateSchemaVersion(topic: string, version: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling updateSchemaVersion.');
        }

        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateSchemaVersion.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateSchemaVersion.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/${encodeURIComponent(String(topic))}/schema/version/${encodeURIComponent(String(version))}`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a storage connector with a specific id and type from a featurestore
     * 
     * @param connectorType storage connector type
     * @param connectorId Id of the storage connector
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling updateStorageConnectorWithId.');
        }

        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling updateStorageConnectorWithId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateStorageConnectorWithId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateStorageConnectorWithId.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}/${encodeURIComponent(String(connectorId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update ACL specified by id.
     * 
     * @param topic 
     * @param id 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTopicAcls(topic: string, id: number, projectId: number, body?: AclDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateTopicAcls(topic: string, id: number, projectId: number, body?: AclDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateTopicAcls(topic: string, id: number, projectId: number, body?: AclDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateTopicAcls(topic: string, id: number, projectId: number, body?: AclDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (topic === null || topic === undefined) {
            throw new Error('Required parameter topic was null or undefined when calling updateTopicAcls.');
        }

        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateTopicAcls.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateTopicAcls.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/topics/${encodeURIComponent(String(topic))}/acls/${encodeURIComponent(String(id))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a training datasets with a specific id from a featurestore
     * 
     * @param trainingdatasetid Id of the training dataset
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param updateMetadata updateMetadata
     * @param updateStats updateStats
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (trainingdatasetid === null || trainingdatasetid === undefined) {
            throw new Error('Required parameter trainingdatasetid was null or undefined when calling updateTrainingDataset.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateTrainingDataset.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateTrainingDataset.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateMetadata !== undefined && updateMetadata !== null) {
            queryParameters = queryParameters.set('updateMetadata', <any>updateMetadata);
        }
        if (updateStats !== undefined && updateStats !== null) {
            queryParameters = queryParameters.set('updateStats', <any>updateStats);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets/${encodeURIComponent(String(trainingdatasetid))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param file 
     * @param flowChunkNumber 
     * @param flowChunkSize 
     * @param flowCurrentChunkSize 
     * @param flowFilename 
     * @param flowIdentifier 
     * @param flowRelativePath 
     * @param flowTotalChunks 
     * @param flowTotalSize 
     * @param templateId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public uploadMethod1(path: string, projectId: number, file?: Blob, flowChunkNumber?: string, flowChunkSize?: string, flowCurrentChunkSize?: string, flowFilename?: string, flowIdentifier?: string, flowRelativePath?: string, flowTotalChunks?: string, flowTotalSize?: string, templateId?: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public uploadMethod1(path: string, projectId: number, file?: Blob, flowChunkNumber?: string, flowChunkSize?: string, flowCurrentChunkSize?: string, flowFilename?: string, flowIdentifier?: string, flowRelativePath?: string, flowTotalChunks?: string, flowTotalSize?: string, templateId?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public uploadMethod1(path: string, projectId: number, file?: Blob, flowChunkNumber?: string, flowChunkSize?: string, flowCurrentChunkSize?: string, flowFilename?: string, flowIdentifier?: string, flowRelativePath?: string, flowTotalChunks?: string, flowTotalSize?: string, templateId?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public uploadMethod1(path: string, projectId: number, file?: Blob, flowChunkNumber?: string, flowChunkSize?: string, flowCurrentChunkSize?: string, flowFilename?: string, flowIdentifier?: string, flowRelativePath?: string, flowTotalChunks?: string, flowTotalSize?: string, templateId?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling uploadMethod1.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling uploadMethod1.');
        }











        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (templateId !== undefined && templateId !== null) {
            queryParameters = queryParameters.set('templateId', <any>templateId);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): void; };
        let useForm = false;
        let convertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        }

        if (file !== undefined) {
            formParams = formParams.append('file', <any>file) || formParams;
        }
        if (flowChunkNumber !== undefined) {
            formParams = formParams.append('flowChunkNumber', <any>flowChunkNumber) || formParams;
        }
        if (flowChunkSize !== undefined) {
            formParams = formParams.append('flowChunkSize', <any>flowChunkSize) || formParams;
        }
        if (flowCurrentChunkSize !== undefined) {
            formParams = formParams.append('flowCurrentChunkSize', <any>flowCurrentChunkSize) || formParams;
        }
        if (flowFilename !== undefined) {
            formParams = formParams.append('flowFilename', <any>flowFilename) || formParams;
        }
        if (flowIdentifier !== undefined) {
            formParams = formParams.append('flowIdentifier', <any>flowIdentifier) || formParams;
        }
        if (flowRelativePath !== undefined) {
            formParams = formParams.append('flowRelativePath', <any>flowRelativePath) || formParams;
        }
        if (flowTotalChunks !== undefined) {
            formParams = formParams.append('flowTotalChunks', <any>flowTotalChunks) || formParams;
        }
        if (flowTotalSize !== undefined) {
            formParams = formParams.append('flowTotalSize', <any>flowTotalSize) || formParams;
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/upload/${encodeURIComponent(String(path))}`,
            convertFormParamsToString ? formParams.toString() : formParams,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public validateSchemaForTopics(projectId: number, body?: SchemaDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public validateSchemaForTopics(projectId: number, body?: SchemaDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public validateSchemaForTopics(projectId: number, body?: SchemaDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public validateSchemaForTopics(projectId: number, body?: SchemaDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling validateSchemaForTopics.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/kafka/schema/validate`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * 
     * 
     * @param path 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public zip(path: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public zip(path: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public zip(path: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public zip(path: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (path === null || path === undefined) {
            throw new Error('Required parameter path was null or undefined when calling zip.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling zip.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/dataset/zip/${encodeURIComponent(String(path))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
