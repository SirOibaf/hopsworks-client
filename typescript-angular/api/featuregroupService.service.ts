/**
 * Hopsworks api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { FeaturegroupDTO } from '../model/featuregroupDTO';
import { FeaturegroupPreview } from '../model/featuregroupPreview';
import { RowValueQueryResult } from '../model/rowValueQueryResult';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class FeaturegroupServiceService {

    protected basePath = '///hopsworks-api/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Create feature group in a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createFeaturegroup.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createFeaturegroup.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete specific featuregroup from a specific featurestore
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete featuregroup contents
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling deleteFeaturegroupContents.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteFeaturegroupContents.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteFeaturegroupContents.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/clear`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get specific featuregroup from a specific featurestore
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Preview feature data of a featuregroup
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturegroupPreview>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturegroupPreview>>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturegroupPreview>>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupPreview.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupPreview.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupPreview.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturegroupPreview>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/preview`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the SQL schema of a featuregroup
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<RowValueQueryResult>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RowValueQueryResult>>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RowValueQueryResult>>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupSchema.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupSchema.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupSchema.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RowValueQueryResult>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/schema`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of feature groups for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturegroupDTO>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturegroupDTO>>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturegroupDTO>>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeaturegroupsForFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturegroupsForFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturegroupDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Synchornize Hive Table with the feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling syncWithFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling syncWithFeaturestore.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/sync`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update featuregroup contents
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param updateMetadata updateMetadata
     * @param updateStats updateStats
     * @param enableOnline enableOnline
     * @param disableOnline disableOnline
     * @param updateStatsSettings updateStatsSettings
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling updateFeaturegroup.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateFeaturegroup.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateFeaturegroup.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateMetadata !== undefined && updateMetadata !== null) {
            queryParameters = queryParameters.set('updateMetadata', <any>updateMetadata);
        }
        if (updateStats !== undefined && updateStats !== null) {
            queryParameters = queryParameters.set('updateStats', <any>updateStats);
        }
        if (enableOnline !== undefined && enableOnline !== null) {
            queryParameters = queryParameters.set('enableOnline', <any>enableOnline);
        }
        if (disableOnline !== undefined && disableOnline !== null) {
            queryParameters = queryParameters.set('disableOnline', <any>disableOnline);
        }
        if (updateStatsSettings !== undefined && updateStatsSettings !== null) {
            queryParameters = queryParameters.set('updateStatsSettings', <any>updateStatsSettings);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
