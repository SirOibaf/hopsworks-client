/**
 * Hopsworks api
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.1.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { ConstraintGroupDTO } from '../model/constraintGroupDTO';
import { DataValidationSettingsDTO } from '../model/dataValidationSettingsDTO';
import { FeaturegroupDTO } from '../model/featuregroupDTO';
import { FeaturegroupImportJobDTO } from '../model/featuregroupImportJobDTO';
import { FeaturegroupPreview } from '../model/featuregroupPreview';
import { FeaturestoreClientSettingsDTO } from '../model/featurestoreClientSettingsDTO';
import { FeaturestoreDTO } from '../model/featurestoreDTO';
import { FeaturestoreStorageConnectorDTO } from '../model/featurestoreStorageConnectorDTO';
import { FeaturestoreUtilJobDTO } from '../model/featurestoreUtilJobDTO';
import { JobDTO } from '../model/jobDTO';
import { RowValueQueryResult } from '../model/rowValueQueryResult';
import { TrainingDatasetDTO } from '../model/trainingDatasetDTO';
import { TrainingDatasetJobDTO } from '../model/trainingDatasetJobDTO';
import { ValidationResult } from '../model/validationResult';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class FeaturestoreServiceService {

    protected basePath = '///hopsworks-api/api';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Write Deequ validation rules to Filesystem so validation job can pick it up
     * 
     * @param featuregroupId 
     * @param featureStoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe?: 'body', reportProgress?: boolean): Observable<DataValidationSettingsDTO>;
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<DataValidationSettingsDTO>>;
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<DataValidationSettingsDTO>>;
    public addValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, body?: ConstraintGroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling addValidationRules.');
        }

        if (featureStoreId === null || featureStoreId === undefined) {
            throw new Error('Required parameter featureStoreId was null or undefined when calling addValidationRules.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling addValidationRules.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<DataValidationSettingsDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featureStoreId))}/datavalidation/${encodeURIComponent(String(featuregroupId))}/rules`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create feature group in a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public createFeaturegroup(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createFeaturegroup.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createFeaturegroup.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new storage connector for the feature store
     * 
     * @param connectorType storage connector type
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public createNewStorageConnectorWithType(connectorType: string, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling createNewStorageConnectorWithType.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createNewStorageConnectorWithType.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createNewStorageConnectorWithType.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Configure job to import featuregroup
     * 
     * @param body Job configuration
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public createOrUpdateImportJob(body: FeaturegroupImportJobDTO, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdateImportJob.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createOrUpdateImportJob.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/importjob`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Configure job to create training dataset
     * 
     * @param body Job configuration
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<JobDTO>;
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<JobDTO>>;
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<JobDTO>>;
    public createOrUpdateTrainingDatasetJob(body: TrainingDatasetJobDTO, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdateTrainingDatasetJob.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createOrUpdateTrainingDatasetJob.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<JobDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/trainingdatasetjob`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create training dataset for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public createTrainingDataset(featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling createTrainingDataset.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling createTrainingDataset.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete specific featuregroup from a specific featurestore
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public deleteFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteFeatureGroupFromFeatureStore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete featuregroup contents
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public deleteFeaturegroupContents(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling deleteFeaturegroupContents.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteFeaturegroupContents.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteFeaturegroupContents.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/clear`,
            null,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete storage connector with a specific id and type from a featurestore
     * 
     * @param connectorType storage connector type
     * @param connectorId Id of the storage connector
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public deleteStorageConnectorWithTypeAndId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteStorageConnectorWithTypeAndId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}/${encodeURIComponent(String(connectorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete a training datasets with a specific id from a featurestore
     * 
     * @param trainingdatasetid Id of the training dataset
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public deleteTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (trainingdatasetid === null || trainingdatasetid === undefined) {
            throw new Error('Required parameter trainingdatasetid was null or undefined when calling deleteTrainingDataset.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling deleteTrainingDataset.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling deleteTrainingDataset.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.delete<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets/${encodeURIComponent(String(trainingdatasetid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get specific featuregroup from a specific featurestore
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public getFeatureGroupFromFeatureStore(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupFromFeatureStore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Preview feature data of a featuregroup
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturegroupPreview>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturegroupPreview>>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturegroupPreview>>>;
    public getFeatureGroupPreview(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupPreview.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupPreview.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupPreview.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturegroupPreview>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/preview`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the SQL schema of a featuregroup
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<RowValueQueryResult>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<RowValueQueryResult>>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<RowValueQueryResult>>;
    public getFeatureGroupSchema(featuregroupId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getFeatureGroupSchema.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeatureGroupSchema.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeatureGroupSchema.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<RowValueQueryResult>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}/schema`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of feature groups for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturegroupDTO>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturegroupDTO>>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturegroupDTO>>>;
    public getFeaturegroupsForFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeaturegroupsForFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturegroupsForFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturegroupDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore with specific Id
     * 
     * @param featurestoreId Id of the featurestore
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreDTO>;
    public getFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreDTO>>;
    public getFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreDTO>>;
    public getFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore with specific name
     * 
     * @param featurestoreName Id of the featurestore
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreDTO>;
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreDTO>>;
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreDTO>>;
    public getFeaturestoreByName(featurestoreName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreName === null || featurestoreName === undefined) {
            throw new Error('Required parameter featurestoreName was null or undefined when calling getFeaturestoreByName.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestoreByName.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/getByName/${encodeURIComponent(String(featurestoreName))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore Metadata
     * 
     * @param featurestoreName 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreClientSettingsDTO>;
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreId(featurestoreName: string, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreName === null || featurestoreName === undefined) {
            throw new Error('Required parameter featurestoreName was null or undefined when calling getFeaturestoreId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestoreId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreClientSettingsDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreName))}/metadata`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get featurestore settings
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestoreSettings(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreClientSettingsDTO>;
    public getFeaturestoreSettings(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreSettings(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreClientSettingsDTO>>;
    public getFeaturestoreSettings(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestoreSettings.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreClientSettingsDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/settings`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of feature stores for the project
     * 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getFeaturestores(projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturestoreDTO>>;
    public getFeaturestores(projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturestoreDTO>>>;
    public getFeaturestores(projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturestoreDTO>>>;
    public getFeaturestores(projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getFeaturestores.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturestoreDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get online featurestore storage connector for this feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public getOnlineFeaturestoreStorageConnector(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getOnlineFeaturestoreStorageConnector.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getOnlineFeaturestoreStorageConnector.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/onlinefeaturestore`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a storage connector with a specific id and type from a featurestore
     * 
     * @param connectorType storage connector type
     * @param connectorId Id of the storage connector
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling getStorageConnectorWithId.');
        }

        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling getStorageConnectorWithId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getStorageConnectorWithId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getStorageConnectorWithId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}/${encodeURIComponent(String(connectorId))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all storage connectors of a feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorageConnectors(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectors(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectors(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectors(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getStorageConnectors.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getStorageConnectors.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturestoreStorageConnectorDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all storage connectors of a specific type of a feature store
     * 
     * @param connectorType storage connector type
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<FeaturestoreStorageConnectorDTO>>;
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<FeaturestoreStorageConnectorDTO>>>;
    public getStorageConnectorsOfType(connectorType: string, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling getStorageConnectorsOfType.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getStorageConnectorsOfType.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getStorageConnectorsOfType.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<FeaturestoreStorageConnectorDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a training datasets with a specific id from a featurestore
     * 
     * @param trainingdatasetid Id of the training dataset
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public getTrainingDatasetWithId(trainingdatasetid: number, featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (trainingdatasetid === null || trainingdatasetid === undefined) {
            throw new Error('Required parameter trainingdatasetid was null or undefined when calling getTrainingDatasetWithId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getTrainingDatasetWithId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTrainingDatasetWithId.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets/${encodeURIComponent(String(trainingdatasetid))}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get the list of training datasets for a featurestore
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<Array<TrainingDatasetDTO>>;
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<TrainingDatasetDTO>>>;
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<TrainingDatasetDTO>>>;
    public getTrainingDatasetsForFeaturestore(featurestoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling getTrainingDatasetsForFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getTrainingDatasetsForFeaturestore.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<Array<TrainingDatasetDTO>>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Fetch the result of a Deequ data validation job
     * 
     * @param featuregroupId 
     * @param featureStoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<ValidationResult>;
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ValidationResult>>;
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ValidationResult>>;
    public getValidationResult(featuregroupId: number, featureStoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getValidationResult.');
        }

        if (featureStoreId === null || featureStoreId === undefined) {
            throw new Error('Required parameter featureStoreId was null or undefined when calling getValidationResult.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getValidationResult.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ValidationResult>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featureStoreId))}/datavalidation/${encodeURIComponent(String(featuregroupId))}/result`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get previously stored Deequ validation rules
     * 
     * @param featuregroupId 
     * @param featureStoreId 
     * @param projectId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'body', reportProgress?: boolean): Observable<ConstraintGroupDTO>;
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ConstraintGroupDTO>>;
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ConstraintGroupDTO>>;
    public getValidationRules(featuregroupId: number, featureStoreId: number, projectId: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling getValidationRules.');
        }

        if (featureStoreId === null || featureStoreId === undefined) {
            throw new Error('Required parameter featureStoreId was null or undefined when calling getValidationRules.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling getValidationRules.');
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<ConstraintGroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featureStoreId))}/datavalidation/${encodeURIComponent(String(featuregroupId))}/rules`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Upload json input for featurestore-util jobs
     * 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public newFeaturestoreUtil(projectId: number, body?: FeaturestoreUtilJobDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling newFeaturestoreUtil.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<any>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/util`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Synchornize Hive Table with the feature store
     * 
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public syncWithFeaturestore(featurestoreId: number, projectId: number, body?: FeaturegroupDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling syncWithFeaturestore.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling syncWithFeaturestore.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            '*/*'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/sync`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update featuregroup contents
     * 
     * @param featuregroupId Id of the featuregroup
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param updateMetadata updateMetadata
     * @param updateStats updateStats
     * @param enableOnline enableOnline
     * @param disableOnline disableOnline
     * @param updateStatsSettings updateStatsSettings
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'body', reportProgress?: boolean): Observable<FeaturegroupDTO>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturegroupDTO>>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturegroupDTO>>;
    public updateFeaturegroup(featuregroupId: number, featurestoreId: number, projectId: number, body?: FeaturegroupDTO, updateMetadata?: boolean, updateStats?: boolean, enableOnline?: boolean, disableOnline?: boolean, updateStatsSettings?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (featuregroupId === null || featuregroupId === undefined) {
            throw new Error('Required parameter featuregroupId was null or undefined when calling updateFeaturegroup.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateFeaturegroup.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateFeaturegroup.');
        }







        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateMetadata !== undefined && updateMetadata !== null) {
            queryParameters = queryParameters.set('updateMetadata', <any>updateMetadata);
        }
        if (updateStats !== undefined && updateStats !== null) {
            queryParameters = queryParameters.set('updateStats', <any>updateStats);
        }
        if (enableOnline !== undefined && enableOnline !== null) {
            queryParameters = queryParameters.set('enableOnline', <any>enableOnline);
        }
        if (disableOnline !== undefined && disableOnline !== null) {
            queryParameters = queryParameters.set('disableOnline', <any>disableOnline);
        }
        if (updateStatsSettings !== undefined && updateStatsSettings !== null) {
            queryParameters = queryParameters.set('updateStatsSettings', <any>updateStatsSettings);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FeaturegroupDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/featuregroups/${encodeURIComponent(String(featuregroupId))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a storage connector with a specific id and type from a featurestore
     * 
     * @param connectorType storage connector type
     * @param connectorId Id of the storage connector
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'body', reportProgress?: boolean): Observable<FeaturestoreStorageConnectorDTO>;
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FeaturestoreStorageConnectorDTO>>;
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FeaturestoreStorageConnectorDTO>>;
    public updateStorageConnectorWithId(connectorType: string, connectorId: number, featurestoreId: number, projectId: number, body?: FeaturestoreStorageConnectorDTO, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (connectorType === null || connectorType === undefined) {
            throw new Error('Required parameter connectorType was null or undefined when calling updateStorageConnectorWithId.');
        }

        if (connectorId === null || connectorId === undefined) {
            throw new Error('Required parameter connectorId was null or undefined when calling updateStorageConnectorWithId.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateStorageConnectorWithId.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateStorageConnectorWithId.');
        }


        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<FeaturestoreStorageConnectorDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/storageconnectors/${encodeURIComponent(String(connectorType))}/${encodeURIComponent(String(connectorId))}`,
            body,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update a training datasets with a specific id from a featurestore
     * 
     * @param trainingdatasetid Id of the training dataset
     * @param featurestoreId 
     * @param projectId 
     * @param body 
     * @param updateMetadata updateMetadata
     * @param updateStats updateStats
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe?: 'body', reportProgress?: boolean): Observable<TrainingDatasetDTO>;
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<TrainingDatasetDTO>>;
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<TrainingDatasetDTO>>;
    public updateTrainingDataset(trainingdatasetid: number, featurestoreId: number, projectId: number, body?: TrainingDatasetDTO, updateMetadata?: boolean, updateStats?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (trainingdatasetid === null || trainingdatasetid === undefined) {
            throw new Error('Required parameter trainingdatasetid was null or undefined when calling updateTrainingDataset.');
        }

        if (featurestoreId === null || featurestoreId === undefined) {
            throw new Error('Required parameter featurestoreId was null or undefined when calling updateTrainingDataset.');
        }

        if (projectId === null || projectId === undefined) {
            throw new Error('Required parameter projectId was null or undefined when calling updateTrainingDataset.');
        }




        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (updateMetadata !== undefined && updateMetadata !== null) {
            queryParameters = queryParameters.set('updateMetadata', <any>updateMetadata);
        }
        if (updateStats !== undefined && updateStats !== null) {
            queryParameters = queryParameters.set('updateStats', <any>updateStats);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<TrainingDatasetDTO>(`${this.basePath}/project/${encodeURIComponent(String(projectId))}/featurestores/${encodeURIComponent(String(featurestoreId))}/trainingdatasets/${encodeURIComponent(String(trainingdatasetid))}`,
            body,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
